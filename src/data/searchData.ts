// This file is auto-generated by scripts/generate-search-data.js
// Do not edit manually - changes will be overwritten during build
// Run 'npm run generate-search' to regenerate from page content

export interface SearchItem {
  id: string;
  title: string;
  description: string;
  content: string;
  url: string;
  category: string;
  tags: string[];
}

export const searchData: SearchItem[] = [
  {
    id: "adding-commands",
    title: "Adding Commands",
    description:
      "Creating and implementing commands to control robot subsystems.",
    content:
      'Command Structure & Examples üéÆ Inline Command Methods Example return runOnce(() -> action); Create commands using factory methods like runOnce() to execute actions once when the command is triggered. addRequirements(subsystem); Commands must declare which subsystems they use to prevent conflicts and ensure proper scheduling. initialize() ‚Üí execute() ‚Üí end() Commands have a clear lifecycle: start, run continuously, then clean up when finished. moveUp(): Positive voltage for upward movement", "‚Ä¢ moveDown(): Negative voltage for downward movement", ], rightTitle: "Command Benefits", rightItems: [ "‚Ä¢ Encapsulation: Actions wrapped in reusable commands", "‚Ä¢ Safety: Automatic stop when command ends", "‚Ä¢ Flexibility: runSlow(): Low voltage (3V) for testing", "‚Ä¢ runFast(): High voltage (6V) for shooting", ], rightTitle: "Command Benefits", rightItems: [ "‚Ä¢ Commands /building-subsystems Subsystems /triggers Triggers Commands - Coordinating Robot Actions Commands are the actions that your robot performs. They use subsystems to accomplish tasks and can be triggered by user input, sensors, or automated sequences. Commands tell subsystems what action to run. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 card p-6 text-xl font-bold text-primary-600 mb-4 cursor-pointer hover:text-primary-700 dark:hover:text-primary-300 mt-4 java Subsystem Command Methods grid md:grid-cols-3 gap-6 ‚ö° Command Methods üîó Command Requirements üîÑ Command Lifecycle Workshop Implementation ‚Ä¢ Arm subsystem with basic voltage control ‚Ä¢ No user input integration ‚Ä¢ No commands to coordinate actions ‚Ä¢ Manual method calls only ‚Ä¢ Enhanced Arm subsystem methods ‚Ä¢ Commands for moveUp(), moveDown() ‚Ä¢ Ready for user input integration Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 2-Commands Arm.java New Subsystem Methods ‚Ä¢ <strong>moveUp():</strong> Positive voltage for upward movement ‚Ä¢ <strong>moveDown():</strong> Negative voltage for downward movement Command Benefits ‚Ä¢ <strong>Encapsulation:</strong> Actions wrapped in reusable commands ‚Ä¢ <strong>Safety:</strong> Automatic stop when command ends ‚Ä¢ <strong>Flexibility:</strong> Ready for trigger integration Enhanced Arm subsystem with command methods! Next, we ‚Ä¢ Flywheel subsystem with basic voltage control ‚Ä¢ Enhanced Flywheel subsystem methods ‚Ä¢ Commands for runSlow(), runFast() src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>runSlow():</strong> Low voltage (3V) for testing ‚Ä¢ <strong>runFast():</strong> High voltage (6V) for shooting Enhanced Flywheel subsystem with command methods! Next, we',
    url: "/adding-commands",
    category: "Workshop 1",
    tags: [
      "adding-commands",
      "command",
      "subsystem",
      "robot",
      "java",
      "workshop",
      "control",
      "frc",
    ],
  },
  {
    id: "ai-assistant",
    title: "ai-assistant",
    description: "",
    content:
      'Ask questions about the FRC Programming Workshop. The AI assistant has access to all workshop content and remembers your conversation history for contextual follow-up questions. Custom API Key (Optional) Get an API key Using custom API key Start a conversation Ask me anything about FRC programming, command-based architecture, PID tuning, or any workshop topics! I remember our conversation, so feel free to ask follow-up questions. ) : ( part.type === "text" ? part.text : "" ) .join(""); return ( Thinking... Error: Send use client react-syntax-highlighter/dist/esm/styles/prism system light gemini-api-key ready submitted streaming AI Workshop Assistant max-w-4xl mx-auto mb-6 flex items-center gap-2 mb-2 true presentation w-6 h-6 text-primary-600 dark:text-primary-400 text-slate-600 dark:text-slate-300 card p-4 mb-4 flex items-start gap-3 w-5 h-5 text-primary-600 dark:text-primary-400 mt-0.5 flex-shrink-0 flex-1 text-sm font-semibold text-slate-700 dark:text-slate-300 text-xs text-slate-600 dark:text-slate-400 mb-3 https://aistudio.google.com/apikey _blank noopener noreferrer text-primary-600 dark:text-primary-400 hover:underline flex gap-2 text password Enter your Gemini API key... flex-1 px-3 py-2 text-sm rounded-lg border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-primary-500 button px-3 py-2 text-sm bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 text-slate-700 dark:text-slate-300 rounded-lg transition-colors Hide Show text-xs text-green-600 dark:text-green-400 mt-2 card p-4 mb-4 min-h-[400px] max-h-[600px] overflow-y-auto flex flex-col items-center justify-center h-full text-center py-12 w-12 h-12 text-slate-400 dark:text-slate-500 mb-4 text-xl font-semibold text-slate-700 dark:text-slate-300 mb-2 text-slate-500 dark:text-slate-400 max-w-md space-y-4 assistant user justify-end justify-start bg-primary-600 text-white bg-slate-100 dark:bg-slate-700 text-slate-900 dark:text-slate-100 break-words whitespace-pre-wrap prose prose-slate dark:prose-invert max-w-none prose-code:text-primary-600 dark:prose-code:text-primary-400 bg-slate-200 dark:bg-slate-600 px-1.5 py-0.5 rounded text-sm font-mono dark div 1rem 0 0.5rem 0.875rem text-primary-600 dark:text-primary-400 hover:underline inline-flex items-center gap-1 http w-3 h-3 text-primary-100 text-slate-500 dark:text-slate-400 flex justify-start bg-slate-100 dark:bg-slate-700 rounded-lg p-4 flex items-center gap-2 animate-spin rounded-full h-4 w-4 border-b-2 border-primary-600 mb-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg flex items-center gap-2 text-red-700 dark:text-red-400 w-5 h-5 font-semibold Ask about subsystems, commands, PID tuning... flex-1 px-4 py-3 rounded-lg border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed submit px-6 py-3 bg-primary-600 hover:bg-primary-700 text-white rounded-lg font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2 w-4 h-4',
    url: "/ai-assistant",
    category: "General",
    tags: ["ai-assistant", "frc", "workshop", "command", "pid"],
  },
  {
    id: "building-subsystems",
    title: "Building Subsystems",
    description:
      "Creating subsystems for robot mechanisms and understanding subsystem structure.",
    content:
      'Subsystem Structure & Code Examples TalonFX motor = new TalonFX(1); Motors, sensors, and other hardware objects are declared as private fields at the top of the class. motor.getConfigurator() &nbsp;&nbsp;&nbsp;&nbsp;.apply(config); Motor configurations, current limits, and mode settings go in the constructor to run once at startup. SmartDashboard.putNumber( &nbsp;&nbsp;&nbsp;&nbsp;"Value", sensor.get()); Runs every 20ms (50Hz). Use for telemetry, monitoring, and updating dashboard values - not for control! TalonFX Motor: Main drive motor with integrated controller", "‚Ä¢ CANcoder: Absolute position feedback sensor", "‚Ä¢ Remote Sensor: CANcoder connected as remote feedback", ], rightTitle: "Key Methods", rightItems: [ "‚Ä¢ setVoltage(): Direct voltage control for basic movement", "‚Ä¢ stop(): Safe motor stop with neutral output", "‚Ä¢ periodic(): Leader Motor: TalonFX controlling the flywheel mechanism", "‚Ä¢ Follower Motor: Second TalonFX following the leader", "‚Ä¢ CANivore Bus: High-speed CAN bus for motor communication", ], rightTitle: "Key Methods", rightItems: [ "‚Ä¢ Direct voltage control for flywheel speed", "‚Ä¢ not have a physical follower motor. However, the following code examples include a follower motor setup to demonstrate best practices for multi-motor subsystems. If implementing on actual hardware, you would either remove the follower motor code or add a second physical motor to your flywheel mechanism. Subsystems /command-framework Command-Based Framework /adding-commands Commands Subsystems - Understanding the Foundation Subsystems form the building blocks of command-based programming. Each subsystem models a physical part of the robot and provides safe, organized methods to control it. Subsystems can vary in scope‚Äîfrom a single motor to an entire mechanism‚Äîdepending on how you choose to structure your code. One subsystem per mechanism. Each subsystem manages its own hardware and state. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 üì¶ Basic Subsystem Example java ExampleSubsystem.java Motor Position Motor Velocity Motor Current grid md:grid-cols-3 gap-6 üîß Hardware Instantiation ‚öôÔ∏è Configuration Location üîÑ Periodic Method Workshop Implementation ‚Ä¢ Basic WPILib project structure ‚Ä¢ No hardware integration ‚Ä¢ No subsystem implementation ‚Ä¢ Complete Arm subsystem class ‚Ä¢ TalonFX motor (ID: 31) configured ‚Ä¢ CANcoder sensor (ID: 22) integrated ‚Ä¢ Basic voltage control methods Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 1-Subsystem Arm.java Hardware Setup ‚Ä¢ <strong>TalonFX Motor:</strong> Main drive motor with integrated controller ‚Ä¢ <strong>CANcoder:</strong> Absolute position feedback sensor ‚Ä¢ <strong>Remote Sensor:</strong> CANcoder connected as remote feedback Key Methods ‚Ä¢ <strong>setVoltage():</strong> Direct voltage control for basic movement ‚Ä¢ <strong>stop():</strong> Safe motor stop with neutral output ‚Ä¢ <strong>periodic():</strong> Understand that periodic runs every robot loop This subsystem is ready for command integration! Next, we ‚Ä¢ Complete Flywheel subsystem class ‚Ä¢ Dual TalonFX motors (IDs: 21, 22) configured ‚Ä¢ Leader/follower motor setup src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>Leader Motor:</strong> TalonFX controlling the flywheel mechanism ‚Ä¢ <strong>Follower Motor:</strong> Second TalonFX following the leader ‚Ä¢ <strong>CANivore Bus:</strong> High-speed CAN bus for motor communication ‚Ä¢ <strong>setVoltage():</strong> Direct voltage control for flywheel speed This flywheel subsystem is ready for command integration! Next, we warning w-6 h-6 none currentColor 0 0 24 24 round M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z Caution: Physical Hardware vs Code Example mb-3 Note mt-3',
    url: "/building-subsystems",
    category: "Workshop 1",
    tags: [
      "building-subsystems",
      "subsystem",
      "motor",
      "hardware",
      "control",
      "command",
      "robot",
      "java",
      "workshop",
      "frc",
    ],
  },
  {
    id: "command-framework",
    title: "Command-Based Framework",
    description:
      "Understanding the command-based programming paradigm and its benefits for robot code organization.",
    content:
      'Use BooleanSuppliers (True or False) Link inputs to commands (e.g., press button to drive forward, or use sensor to run Command automatically). All buttons/triggers on a game controller are considered "Triggers". Hardware components and control logic (e.g., Drivetrain, Arm, or Flywheel). Motors and sensors are instantiated. Methods to pull data from sensors within the subsystem are defined. Use Runnables (void functions) Encapsulate robot actions (e.g., DriveForwardCommand, ShootBallCommand). Progressive Implementation Path Follow our step-by-step implementation guide to build a complete command-based robot system. Each pull request builds on the previous one, teaching core concepts progressively. üöÄ Implementation Sequence Building Subsystems Hardware instantiation, motor configuration, and basic control methods Adding Commands Command structure and creation methods Triggers User input binding and advanced command patterns PID Control Precise position control with feedback and tuning Motion Magic Smooth profiled motion with acceleration control Useful Functions Safety features, diagnostics, and utility functions üìö Official WPILib Command-Based Documentation For comprehensive Command-Based Framework reference, advanced patterns, and complete API documentation: Command-Based Framework /project-setup Project Setup /building-subsystems Command-Based Framework - Core Programming Concepts The Command-Based Framework organizes robot code into three key components: Triggers (inputs), Subsystems (hardware), and Commands (actions). This structure provides clean separation of concerns and reliable robot behavior. Command-based programming is the format in which you will write your code. grid md:grid-cols-3 gap-6 Subsystems Commands flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 grid md:grid-cols-1 gap-6 text-xl font-bold text-[var(--foreground)] mb-4 space-y-4 flex items-center gap-4 p-4 bg-primary-50 dark:bg-primary-950/20 rounded-lg bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-700 dark:text-primary-300 text-primary-600 dark:text-primary-400 text-sm flex items-center gap-4 p-4 bg-primary-100 dark:bg-primary-900/30 rounded-lg bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-800 dark:text-primary-200 text-primary-700 dark:text-primary-300 text-sm flex items-center gap-4 p-4 bg-primary-200 dark:bg-primary-800/40 rounded-lg bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-900 dark:text-primary-100 text-primary-800 dark:text-primary-200 text-sm flex items-center gap-4 p-4 bg-primary-300 dark:bg-primary-700/50 rounded-lg bg-primary-800 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-950 dark:text-white text-primary-900 dark:text-primary-100 text-sm flex items-center gap-4 p-4 bg-primary-400 dark:bg-primary-600/60 rounded-lg bg-primary-900 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-slate-900 dark:text-white text-slate-800 dark:text-slate-100 text-sm flex items-center gap-4 p-4 bg-primary-500 dark:bg-primary-500/70 rounded-lg bg-slate-900 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-[var(--foreground)] mb-4 https://docs.wpilib.org/en/stable/docs/software/commandbased/index.html WPILib Command-Based Programming Guide w-5 h-5',
    url: "/command-framework",
    category: "Workshop 1",
    tags: [
      "command-framework",
      "command",
      "hardware",
      "control",
      "subsystem",
      "robot",
      "motor",
      "pid",
    ],
  },
  {
    id: "hardware",
    title: "Hardware Setup",
    description:
      "Overview of CTRE hardware components including Kraken X44 motors, CANcoders, and CANivore setup.",
    content:
      'Hardware Components Kraken X44 Brushless Motor Powered by Talon FX‚Ñ¢ Compact brushless motor with integrated Talon FX‚Ñ¢ controller. Delivers 823W peak power. Key Features: 4.05Nm stall torque, 85% max efficiency, 125.5 RPS max speed, SplineXS shaft, FOC commutation, 1kHz PID control, compact 44mm design. WCP ThroughBore Encoder ‚Äì CAN Bus Position Sensor Through bore rotary sensor using innovative off-axis magnet technology. Eliminates mechanical coupling for precise shaft position measurement. 1/2" hex shaft compatible, through bore design, absolute/relative position, CAN bus connectivity, versatile mounting options. CANivore‚Ñ¢ ‚Äì CAN FD Bus Expansion USB-to-CAN FD interface that adds new CAN FD network to PC or roboRIO. Enables precise control of CTRE devices with Phoenix Pro and hardware-attached simulation. CAN FD technology (2X-8X better bus utilization), wireless configuration, ESP32 integration, multi-color status LEDs, USB Type-C support. Why We Choose CTRE Hardware üéØ CTRE\'s Unique Advantages Full PID Control Complete PID implementation with kP, kI, kD, and advanced filtering options that other vendors don\'t provide. Feedforward (FF) Built-in feedforward control for gravity compensation and velocity control that competitors lack. Motion Profiling Advanced Motion Magic and motion profiling capabilities for smooth, controlled movements. Rotations Units Motor positions measured in intuitive rotations instead of confusing encoder ticks or radians. üîß Phoenix Software Resources ‚Üí CANivore Introduction ‚Üí Phoenix 6 Documentation ‚Üí Phoenix 6 API Reference ‚Üí Phoenix Tuner X Documentation Connecting to Your Device Plug the computer into CANivore Make sure the "CANivore USB" is checked Change "Team # or IP" to "localhost" Your CANivore should now appear in Phoenix Tuner For this workshop, please name your CANivore: "canivore" Updating Your CTRE Products Using Phoenix Tuner Open Phoenix Tuner and connect to your robot If you have issues connecting to your robot, view this guide Batch update all products of the same model Select one of the devices and then click the batch update icons Verify Updates The device cards will be green if the firmware is the latest Motor Update Process & Status Colors üì± How to Update Motors Use Phoenix Tuner to update your motor firmware. Select devices and use the batch update feature to ensure all motors are running the latest firmware version. The color of the device cards is helpful as a visual indicator of device state. The meaning of the card color is also shown as text underneath the device title. Color Description Green Device has latest firmware. Purple Device has an unexpected/beta firmware version. Yellow A new firmware version is available. Red Device has a duplicate ID. Blue Failed to retrieve list of available firmware. Always update all motors to the same firmware version for consistency and use batch update to save time when updating multiple devices. Having Issues? If you are having issues connecting to your CANivore or other devices, make sure to update your CANivore firmware. Let\'s Run Some Motors! Testing Motor Movement Quick Test Steps: Open up your motor in Phoenix Tuner Click Config Click the three dots Factory Default Set the drop-down to Voltage Out DISABLED to enable Apply voltage to test the motor ‚ö° Safety First Always start with low voltage values when testing motors. Make sure your mechanism can move freely and won\'t cause damage. Hardware Setup /mechanism-cad Mechanism CAD /project-setup Project Setup Hardware Setup - Building the Foundation Overview of the motors, sensors, and controllers you Solid hardware configuration enables precise and reliable robot control. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-1 lg:grid-cols-3 gap-8 /images/hardware/Kraken44x.png Kraken Motor mb-4 text-xl font-bold text-slate-900 dark:text-slate-100 mb-3 https://store.ctr-electronics.com/products/kraken-x44 _blank noopener noreferrer text-primary-600 hover:text-primary-800 underline dark:text-primary-400 dark:hover:text-primary-300 text-slate-600 dark:text-slate-300 mb-3 bg-primary-100 dark:bg-primary-900/20 p-3 rounded-lg text-sm text-primary-800 dark:text-primary-300 /images/hardware/Encoder.png CANcoder https://store.ctr-electronics.com/products/wcp-throughbore-encoder /images/hardware/CANivore.png CANivore https://store.ctr-electronics.com/canivore/ bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-4 grid md:grid-cols-4 gap-4 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 font-bold text-primary-600 dark:text-primary-400 mb-2 text-sm text-slate-600 dark:text-slate-300 font-bold text-[var(--foreground)] mb-2 font-bold text-green-600 dark:text-green-400 mb-2 font-bold text-orange-600 dark:text-orange-400 mb-2 mt-8 bg-slate-50 dark:bg-slate-900 rounded-lg p-6 border border-slate-200 dark:border-slate-800 grid md:grid-cols-2 gap-4 https://v6.docs.ctr-electronics.com/en/stable/docs/canivore/canivore-intro.html block text-primary-600 underline hover:no-underline hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300 font-medium https://v6.docs.ctr-electronics.com/ https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/ https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/ warning ‚ö†Ô∏è Important Setup Steps list-decimal list-inside space-y-2 p-8 space-y-4 flex items-start space-x-3 bg-green-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold font-medium text-slate-600 dark:text-slate-300 text-sm https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/connecting.html#connecting-tuner text-primary-600 underline hover:no-underline dark:text-primary-400 ml-1 mx-auto flex flex-col gap-4 text-xl font-semibold text-slate-900 dark:text-slate-100 https://www.youtube.com/embed/aktcCtcrEyY Motor Update Process accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full h-full aspect-video rounded-lg info üé® Card Colors mb-3 bg-slate-50 dark:bg-slate-900 rounded-lg p-4 overflow-x-auto w-full text-left border-b border-slate-200 dark:border-slate-700 py-2 px-3 font-semibold text-slate-900 dark:text-slate-100 w-32 py-2 px-3 font-semibold text-slate-900 dark:text-slate-100 text-sm border-b border-slate-100 dark:border-slate-800 py-3 px-3 align-top flex items-center whitespace-nowrap inline-block w-4 h-4 bg-green-500 rounded-full mr-2 flex-shrink-0 text-green-700 dark:text-green-400 py-3 px-3 text-slate-700 dark:text-slate-300 align-top inline-block w-4 h-4 bg-purple-500 rounded-full mr-2 flex-shrink-0 text-purple-700 dark:text-purple-400 inline-block w-4 h-4 bg-yellow-500 rounded-full mr-2 flex-shrink-0 text-yellow-700 dark:text-yellow-400 inline-block w-4 h-4 bg-red-500 rounded-full mr-2 flex-shrink-0 text-red-700 dark:text-red-400 inline-block w-4 h-4 bg-blue-500 rounded-full mr-2 flex-shrink-0 text-blue-700 dark:text-primary-400 tip üí° Tip mt-4 text-slate-600 dark:text-slate-300 https://www.youtube.com/embed/TkScJADvD-Y CANivore Setup bg-primary-100 dark:bg-primary-900/20 border border-blue-200 dark:border-blue-900 rounded-lg p-6 text-lg font-semibold text-primary-900 dark:text-primary-300 mb-4 grid md:grid-cols-2 gap-6 mb-6 font-semibold text-[var(--foreground)] mb-3 list-decimal list-inside space-y-2 text-[var(--foreground)] bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-[var(--border)] font-semibold text-slate-900 dark:text-slate-100 mb-2 https://www.youtube.com/embed/cDWF3bj1Juk Motor Test',
    url: "/hardware",
    category: "Workshop 1",
    tags: ["hardware", "motor", "pid", "control", "ctre", "workshop", "robot"],
  },
  {
    id: "introduction",
    title: "Introduction - Gray Matter Coding Workshop",
    description:
      "Overview of the workshop goals, target audience, and what you'll learn about FRC programming best practices.",
    content:
      "Quick Note All underlined text and images of code or products will have built-in links to resources Before You Begin Review prerequisites Why Are We Here? Learn FRC's Best Programming Practices Master industry-standard coding patterns, command-based architecture, and proven development workflows that successful FRC teams use. Build Competition-Winning Robots Develop reliable, maintainable code that performs under pressure and helps your team succeed at districts, regionals and FIRST Championship. Target Audience & Goals Who This Workshop Is For This workshop is designed for FRC Teams using Java and CTRE Hardware. What You'll Learn ‚Ä¢ Code architecture and best practices ‚Ä¢ Subsystems structure and organization ‚Ä¢ Command-based programming framework ‚Ä¢ PID tuning techniques ‚Ä¢ Libraries and framework usage ‚Ä¢ Hardware integration with CTRE devices ‚Ä¢ Motion profiling and control ‚Ä¢ Real-world competition implementation Our Mission This site was created by Team 5712, Hemlocks Gray Matter, with support from its friends as a resource to cover introductory to advanced topics while providing a clear learning and implementation plan. We are excited for you to learn code architecture, command-based programming, and more! Choose Your Workshop Workshop #1 Fundamentals of FRC programming with command-based framework, subsystems, and PID control. Hardware Setup Project Setup Mechanism Setup Command-Based Framework Building Subsystems Adding Commands Triggers Running Program PID Control Motion Magic State-Based Control Start Workshop #1 Workshop #2 Advanced topics including swerve drive, vision systems, path planning, and data logging. Swerve Prerequisites Swerve Drive Project PathPlanner Logging Options Logging Implementation Vision Options Vision Implementation Odometry Calibration Vision-Based Shooting Start Workshop #2 Gray Matter Coding Workshop Home /prerequisites Prerequisites bg-primary-50 dark:bg-primary-950/30 border-l-4 border-primary-400 dark:border-primary-900 p-6 text-lg font-medium text-primary-900 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300 bg-amber-50 dark:bg-amber-950/30 border-l-4 border-amber-400 dark:border-amber-900 p-6 text-lg font-medium text-amber-900 dark:text-amber-300 mb-2 text-amber-800 dark:text-amber-300 underline font-semibold hover:text-amber-900 dark:hover:text-amber-200 transition-colors flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 space-y-6 border-l-4 border-orange-200 dark:border-orange-900 pl-4 text-lg font-semibold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 mt-2 border-l-4 border-green-200 dark:border-green-900 pl-4 border-l-4 border-purple-200 dark:border-purple-900 pl-4 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-3 text-lg text-slate-600 dark:text-slate-300 mb-4 border-l-4 border-blue-200 dark:border-blue-900 pl-4 grid md:grid-cols-2 gap-4 space-y-2 text-slate-600 dark:text-slate-300 border-l-4 border-amber-200 dark:border-amber-900 pl-4 text-lg text-slate-600 dark:text-slate-300 grid grid-cols-1 lg:grid-cols-2 gap-6 lg:gap-8 bg-slate-50 dark:bg-slate-900 rounded-lg p-6 sm:p-8 shadow-lg border border-slate-200 dark:border-slate-800 hover:shadow-xl transition-shadow flex items-center mb-4 w-12 h-12 bg-primary-600 rounded-lg flex items-center justify-center text-white font-bold text-xl mr-4 text-2xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 mb-6 space-y-3 mb-6 /hardware block p-3 bg-slate-100 dark:bg-slate-800 rounded-lg hover:bg-primary-100 dark:hover:bg-primary-950/30 transition-colors group flex items-center justify-between font-medium text-slate-700 dark:text-slate-300 group-hover:text-primary-700 dark:group-hover:text-primary-300 text-slate-400 dark:text-slate-500 group-hover:text-primary-500 dark:group-hover:text-primary-300 /project-setup /mechanism-setup /command-framework /building-subsystems /adding-commands /triggers /running-program /pid-control /motion-magic /state-based w-full bg-primary-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-primary-700 transition-colors text-center block /swerve-prerequisites /swerve-drive-project /pathplanner /logging-options /logging-implementation /vision-options /vision-implementation /swerve-calibration /vision-shooting",
    url: "/introduction",
    category: "Getting Started",
    tags: [
      "introduction",
      "frc",
      "command",
      "workshop",
      "java",
      "ctre",
      "hardware",
      "pid",
      "control",
    ],
  },
  {
    id: "logging-implementation",
    title: "Implementing Logging",
    description:
      "Setting up and implementing comprehensive logging systems for robot data collection.",
    content:
      "Using WPILib Epilogue WPILib 2025+ includes Epilogue, an annotation-based logging framework that automatically generates logging code at compile time. Instead of manually publishing data to NetworkTables, you simply annotate your classes with @Logged. Zero boilerplate: No SmartDashboard.put() calls in periodic() Compile-time generation: Efficient code with no runtime overhead Automatic discovery: Logs all public fields/getters unless marked @NotLogged Built into WPILib 2025: No extra dependencies required DataLogManager Examples To log data from your subsystems, publish it to NetworkTables using SmartDashboard or NetworkTableInstance. DataLogManager will automatically capture it. Don't overdo it: Logging too much data can impact loop timing Use appropriate keys: Organize data with hierarchical keys (e.g., \"Subsystem/Parameter\") Avoid String spam: Strings are expensive to log at high frequency Consider sampling rate: Not all data needs 50Hz logging Workshop Code Implementation For this workshop we will use DataLogManager and Epilogue, as they work perfectly together and are built into WPILib. Robot.java - Adding Logging RobotContainer.java includes logging setup for subsystems and commands. This helps track which commands are running and monitor subsystem state. Subsystems use Epilogue's @Logged annotation to automatically log data. This example shows the CommandSwerveDrivetrain with Epilogue logging enabled. AdvantageScope AdvantageScope is a powerful log visualization tool that can both read .wpilog files for post-match analysis and connect to your robot in real-time for live data monitoring. üì° Real-Time Data Viewing AdvantageScope can connect to your robot while it's running to view live data through NetworkTables. Open AdvantageScope on your driver station Select \"Connect to Robot\" from the menu Enter your team number or robot IP address (e.g., roborio-TEAM-frc.local) AdvantageScope connects via NetworkTables Add graphs and visualizations to monitor data in real-time Perfect for tuning PID controllers and debugging sensors üì• Post-Match Log Analysis Download and analyze .wpilog files after matches for detailed performance review. Connect to roboRIO via USB or WiFi Open web browser to roborio-TEAM-frc.local Navigate to the /logs/ directory Download .wpilog files from recent matches Open the log file in AdvantageScope Add line graphs for numeric data Use 3D field view for odometry visualization Scrub timeline to analyze specific moments When connecting to your robot in real-time, AdvantageScope uses NetworkTables to subscribe to the data being published by your robot code. This means: You can see live sensor values and motor outputs as your robot runs Changes to PID gains or other parameters can be tested immediately No need to wait for match completion to download and analyze logs Real-time data is not automatically saved unless DataLogManager is enabled Overlay multiple signals: Compare target vs actual values on same graph Video sync: Sync log data with match video for context Save layouts: Create reusable dashboard layouts for quick analysis Logging Best Practices ‚úÖ Do Log sensor inputs and motor outputs Use hierarchical key naming (Subsystem/Parameter) Log target setpoints alongside actual values Include timestamps for event logging Download logs after every match Review logs between matches to catch issues ‚ùå Don't Log high-frequency strings (use numbers/booleans) Publish the same data multiple times Ignore loop overrun warnings from excessive logging Additional Resources What's Next? Up Next: Vision Options With logging configured, you're ready to add computer vision for AprilTag localization and field-aware control. Implementing Logging /logging-options Logging Options /vision-options Vision Options Setting Up Data Logging Implementing logging in your robot code is straightforward with WPILib A few lines of code unlock comprehensive data logging for debugging and analysis. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 java Subsystem with @Logged Annotation tip üí° Epilogue Benefits list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 https://docs.wpilib.org/en/stable/docs/software/telemetry/robot-telemetry-with-annotations.html WPILib Epilogue Documentation üìä Subsystem Telemetry Example Subsystem with Telemetry canivore Arm/Position Arm/Velocity Arm/Current Arm/Voltage Arm/Temperature Arm/TargetPosition Arm/Error üó∫Ô∏è Logging Robot Pose Swerve Drive Odometry Logging Odometry/X Odometry/Y Odometry/Heading Odometry/Pose Swerve/Module /Angle /Speed warning ‚ö†Ô∏è Performance Considerations text-2xl font-semibold text-slate-900 dark:text-slate-100 Hemlock5712/Workshop-Code 2-Logging src/main/java/frc/robot/Robot.java Robot.java RobotContainer.java text-slate-600 dark:text-slate-300 mb-4 src/main/java/frc/robot/RobotContainer.java üîß Subsystem Logging Example src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java CommandSwerveDrivetrain.java grid md:grid-cols-2 gap-6 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-4 text-sm text-slate-600 dark:text-slate-300 mb-3 list-decimal list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 info üí° NetworkTables Connection mb-3 üí° AdvantageScope Pro Tips https://github.com/Mechanical-Advantage/AdvantageScope/blob/main/docs/INDEX.md AdvantageScope Documentation w-5 h-5 bg-green-50 dark:bg-green-900/20 p-6 rounded-lg border-l-4 border-green-500 text-lg font-semibold text-green-900 dark:text-green-300 mb-4 bg-red-50 dark:bg-red-900/20 p-6 rounded-lg border-l-4 border-red-500 text-lg font-semibold text-red-900 dark:text-red-300 mb-4 grid md:grid-cols-2 gap-4 https://docs.wpilib.org/en/stable/docs/software/telemetry/datalog.html WPILib DataLogManager Documentation https://github.com/Mechanical-Advantage/AdvantageScope AdvantageScope GitHub https://docs.wpilib.org/en/stable/docs/software/dashboards/smartdashboard/index.html SmartDashboard Documentation https://docs.wpilib.org/en/stable/docs/software/networktables/index.html NetworkTables Documentation bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/logging-implementation",
    category: "Workshop 2",
    tags: [
      "logging-implementation",
      "subsystem",
      "workshop",
      "robot",
      "java",
      "frc",
      "pid",
      "motor",
      "control",
    ],
  },
  {
    id: "logging-options",
    title: "Logging Options",
    description:
      "Data logging options for robot debugging, analysis, and performance monitoring.",
    content:
      "Why Logging is Critical in FRC üéØ The Logging Challenge During a match, your robot operates for only 2-3 minutes. When something goes wrong, you need to quickly understand what happened and fix it before the next match. Without logging, you're debugging blind. ‚ùå Without Logging Guess what went wrong based on driver observation Attempt to reproduce issues in the pits Waste time debugging problems that already occurred Miss subtle performance issues and edge cases Struggle to tune PID and feedforward values ‚úÖ With Comprehensive Logging Replay exact robot state from any match Analyze sensor data, motor outputs, and commands Identify root causes of failures quickly Optimize performance with data-driven decisions Tune PID values using real match data See exactly what your robot was doing when something went wrong. No more guessing or trying to reproduce issues. Analyze PID response curves, feedforward effectiveness, and mechanism performance with real match data. Track performance metrics across matches to identify trends and opportunities for improvement. Top FRC teams invest heavily in data logging infrastructure. Being able to quickly diagnose and fix issues between matches can mean the difference between winning and losing in elimination rounds. Modern logging frameworks make it easier than ever to capture comprehensive data without impacting robot performance. What Should You Log? Effective logging captures all relevant robot state while managing data volume and performance impact: üéÆ Inputs Joystick values and button presses Sensor readings (encoders, gyros, limit switches) Vision detection results NetworkTables values Game-specific data (alliance, match number) ü§ñ Robot State Motor outputs (voltage, current, duty cycle) Mechanism positions and velocities Robot pose (X, Y, heading) Subsystem states and modes Active commands ‚öôÔ∏è Control Signals Target setpoints and actual values PID error and output Feedforward calculations Path following targets Control loop timing While comprehensive logging is valuable, excessive logging can impact robot performance: Network bandwidth: Don't spam NetworkTables with high-frequency data CPU overhead: Logging shouldn't slow down control loops Storage space: Log files can grow large with high-frequency data Best practice: Use efficient binary logging formats and appropriate sample rates FRC Logging Framework Options Several logging frameworks are available for FRC teams. Each has different features, complexity, and use cases: DataLogManager (WPILib Built-in) Official WPILib data logging system that captures all NetworkTables data to binary .wpilog files. ‚úÖ Advantages Built into WPILib - no additional dependencies Automatically logs all NetworkTables data Efficient binary format (.wpilog) for compact storage Integrated with AdvantageScope for visualization Simple setup with one line of code Low performance overhead ‚ö†Ô∏è Limitations Only logs data published to NetworkTables No built-in replay/simulation capabilities Requires manual data publication from code Less structured than framework-based approaches üéØ Best For Teams who want simple, effective logging without additional framework complexity. Ideal for most FRC teams. AdvantageKit Comprehensive logging and replay framework developed by Team 6328 (Mechanical Advantage). Industry-leading solution for advanced teams. Deterministic replay: Re-run robot code with logged data Hardware abstraction: IO layer separation for testability Comprehensive capture: All inputs/outputs logged automatically Time-travel debugging: Step through logged matches Simulation support: Test code without hardware Integrates with AdvantageScope for visualization Significant code restructuring required Steeper learning curve for implementation Requires understanding of IO layer pattern More complex setup and maintenance Best adopted at start of season, not mid-season Advanced teams who want deterministic replay, time-travel debugging, and comprehensive testing capabilities. Requires significant investment in code architecture. Hoot Logging Lightweight logging framework specifically designed for CTRE Phoenix 6 and modern FRC hardware. Optimized for Phoenix 6 signals and CTRE hardware Automatic capture of motor controller telemetry Low overhead with efficient signal logging Simple API for custom logging Outputs to .wpilog format Works well with CANivore high-frequency data Focused primarily on CTRE ecosystem Less comprehensive than AdvantageKit Smaller community and documentation Teams using CTRE Phoenix 6 hardware who want optimized logging for motor controllers and CANivore devices. WPILib Epilogue (Java Only) Annotation-based logging framework built into WPILib 2025+. Automatically generates logging code at compile time using the @Logged annotation. Zero boilerplate: Add @Logged annotation, get automatic logging Generates efficient logging code at compile time (no runtime overhead) Logs to NetworkTables and DataLog automatically Integrates seamlessly with AdvantageScope Configurable timing (defaults to 50Hz offset from robot loop) Performance metrics logged to NetworkTables Java only (not available for C++ or Python) Requires WPILib 2025 or later Only available for teams using annotation processing (Gradle default) Less control than manual logging approaches New in 2025 - still maturing Java teams using WPILib 2025+ who want comprehensive logging with minimal code. Perfect for teams who want the simplicity of DataLogManager with better structure and less manual code. Logging Framework Comparison Feature DataLogManager Epilogue Setup Complexity Very Easy - One line Very Easy - Annotations Complex - Major restructure Easy - Simple integration Learning Curve Minimal Steep Moderate Performance Impact Very Low Very Low (compile-time) Low (when properly configured) Data Capture NetworkTables only Annotated classes Comprehensive (all I/O) Focused on CTRE devices Replay Capability No (visualization only) Yes (deterministic) Yes (limited) Visualization AdvantageScope AdvantageScope or Tuner X Community Support WPILib official Strong (Team 6328) Growing Best Use Case Most teams, simple logging Java teams, minimal boilerplate Advanced teams, comprehensive testing CTRE-focused teams Recommended Approach for This Workshop üìä Using DataLogManager + Epilogue For this workshop, we'll use a combination of WPILib's DataLogManager and Epilogue for structured annotation-based logging. This provides: Why DataLogManager? Simple setup with minimal code changes Automatic capture of NetworkTables data Official WPILib support and maintenance Works with AdvantageScope for visualization Why Add Epilogue? Zero boilerplate with @Logged annotations Automatic structured logging of subsystems Compile-time code generation (no runtime overhead) Built into WPILib 2025 - no extra dependencies As your team's sophistication grows, consider migrating to AdvantageKit for deterministic replay and comprehensive testing. However, start simple with DataLogManager + Epilogue to build good logging habits before adopting more complex frameworks. Additional Resources What's Next? Up Next: Implementing Logging Now that you understand the logging framework options, you'll implement DataLogManager and Epilogue in your robot code to capture telemetry. Logging Options /pathplanner Adding PathPlanner /logging-implementation Implementing Logging Data Logging - Understanding What Happened Data logging captures robot telemetry, sensor values, and system state during operation. This data is essential for debugging issues, analyzing performance, tuning mechanisms, and understanding what happened during a match. Comprehensive logging transforms debugging from guesswork into data-driven problem solving. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-6 text-slate-600 dark:text-slate-300 mb-6 grid md:grid-cols-2 gap-6 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 font-bold text-red-600 dark:text-red-400 mb-3 text-lg list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 font-bold text-green-600 dark:text-green-400 mb-3 text-lg grid md:grid-cols-3 gap-6 Debug Faster Tune Better Improve Continuously info üí° Logging is a Competitive Advantage mb-3 text-sm text-slate-600 dark:text-slate-300 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 lg:grid-cols-3 gap-6 bg-primary-100 dark:bg-primary-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-primary-900 dark:text-primary-300 bg-green-100 dark:bg-green-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-green-900 dark:text-green-300 bg-orange-100 dark:bg-orange-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-orange-900 dark:text-orange-300 warning ‚ö†Ô∏è Balance Detail with Performance list-disc list-inside space-y-2 text-slate-600 dark:text-slate-300 bg-slate-50 dark:bg-slate-900 rounded-lg p-8 border border-slate-200 dark:border-slate-800 flex items-start gap-4 mb-6 bg-primary-600 text-white rounded-lg px-4 py-2 font-bold text-lg flex-1 text-2xl font-bold text-slate-900 dark:text-slate-100 mb-2 font-semibold text-slate-900 dark:text-slate-100 mb-3 mt-6 bg-green-600 text-white rounded-lg px-4 py-2 font-bold text-lg https://github.com/Mechanical-Advantage/AdvantageKit AdvantageKit GitHub Repository w-5 h-5 bg-orange-600 text-white rounded-lg px-4 py-2 font-bold text-lg bg-blue-600 text-white rounded-lg px-4 py-2 font-bold text-lg https://docs.wpilib.org/en/stable/docs/software/telemetry/robot-telemetry-with-annotations.html WPILib Epilogue Documentation overflow-x-auto w-full border-collapse border-b-2 border-slate-300 dark:border-slate-700 text-left p-4 font-semibold text-slate-900 dark:text-slate-100 border-b border-slate-200 dark:border-slate-800 p-4 font-medium text-slate-900 dark:text-slate-100 p-4 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 gap-6 mb-6 font-bold text-primary-600 dark:text-primary-400 mb-3 font-bold text-green-600 dark:text-green-400 mb-3 üí° Future Considerations grid md:grid-cols-2 gap-4 https://docs.wpilib.org/en/stable/docs/software/telemetry/datalog.html WPILib DataLogManager Documentation AdvantageKit GitHub https://github.com/Mechanical-Advantage/AdvantageScope AdvantageScope - Log Visualization https://v6.docs.ctr-electronics.com/ Phoenix 6 Documentation bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/logging-options",
    category: "Workshop 2",
    tags: [
      "logging-options",
      "frc",
      "robot",
      "pid",
      "motor",
      "subsystem",
      "control",
      "hardware",
      "ctre",
      "java",
      "workshop",
    ],
  },
  {
    id: "mechanism-cad",
    title: "Mechanism CAD",
    description:
      "3D CAD models and visualization of robot mechanisms used in the workshop.",
    content:
      "(null); const armModelRef = useRef (null); return ( Interactive 3D Models Flywheel Mechanism This 3D model represents the mechanism you'll be programming in this workshop. Use your mouse to orbit around the model, zoom in/out, and examine the design from different angles. üì¶ Download STL üîß Download STP üñ®Ô∏è Bambu Files - Coming Soon Arm Mechanism An Arm mechanism for Workshop programming. This arm mechanism demonstrates precise positioning and control concepts that are essential in FRC robotics. STL Files Standard format for 3D printing. Compatible with most slicers including PrusaSlicer, Cura, and Bambu Studio. STP Files CAD format for editing and modification. Opens in Fusion 360, SolidWorks, and other CAD software. What's Next? Ready for Programming!!! Now that you have a mechanism, you're ready to move on to connecting and configuring the code to make this work. We'll cover motors, sensors, and controllers needed to bring this CAD model to life. use client Mechanism CAD /prerequisites Prerequisites /hardware Hardware Setup Mechanism CAD - 3D Model Exploration Before diving into programming, we first need a physical mechanism. If you do not have a previous robot or mechanism below are 3D models of mechanisms you can build affordably. Interactive 3D model of the Flywheel mechanism. flex flex-col gap-8 -mx-4 sm:-mx-6 md:-mx-8 lg:-mx-12 xl:-mx-16 text-3xl font-bold text-slate-900 dark:text-slate-100 px-4 sm:px-6 md:px-8 lg:px-12 xl:px-16 bg-slate-50 dark:bg-slate-900 rounded-lg p-4 md:p-8 shadow-lg border border-slate-200 dark:border-slate-800 mx-4 sm:mx-6 md:mx-8 lg:mx-12 xl:mx-16 flex flex-col gap-6 w-full /cad/HTTI Mechanism v2 - Shooter Mode.gltf w-full h-64 sm:h-80 md:h-96 lg:h-[600px] shadow-lg text-center space-y-4 text-xl font-semibold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 max-w-2xl flex gap-3 /cad/HTTI Mechanism v2 - Shooter Mode.stl flex-1 bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-lg text-center font-medium transition-colors /cad/HTTI Mechanism v2 - Shooter Mode.stp flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg text-center font-medium transition-colors bg-slate-300 dark:bg-slate-700 text-slate-500 dark:text-slate-400 px-4 py-2 rounded-lg text-center font-medium cursor-not-allowed mt-2 /cad/HTTI Mechanism v2 - Arm Mode.gltf /cad/HTTI Mechanism v2 - Arm Mode.stl /cad/HTTI Mechanism v2 - Arm Mode.stp px-4 sm:px-6 md:px-8 lg:px-12 xl:px-16 info üìã File Format Guide grid md:grid-cols-2 gap-4 text-sm font-bold text-blue-800 dark:text-blue-300 mb-2 text-blue-700 dark:text-blue-300 mt-8 px-4 sm:px-6 md:px-8 lg:px-12 xl:px-16 Shooter Mechanism flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-primary-200 dark:border-primary-900 flex items-start space-x-4 flex-shrink-0 flex items-center justify-center w-12 h-12 bg-primary-100 dark:bg-primary-900/50 rounded-lg w-6 h-6 text-primary-600 dark:text-primary-400 none currentColor 0 0 24 24 round M13 10V3L4 14h7v7l9-11h-7z text-lg font-semibold text-primary-900 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300",
    url: "/mechanism-cad",
    category: "Resources",
    tags: ["mechanism-cad", "workshop", "control", "frc", "hardware", "robot"],
  },
  {
    id: "mechanism-setup",
    title: "Mechanism Setup",
    description:
      "Configuring specific robot mechanisms and their control systems.",
    content:
      '("arm"); return ( Warning: Stop Code Before Hardware Setup stop any running code the "CANivore USB" setting in TunerX. This ensures proper communication with physical hardware during testing and configuration. Steps: Stop any running robot code ‚Üí Open TunerX ‚Üí Go to CANivore settings ‚Üí Enable "CANivore USB" Setup Steps by Mechanism ü¶æ Arm Mechanism ‚ö° Flywheel Mechanism üìù Important Note: Encoder Replacement If you replace your encoder with a new one, you will need to repeat these setup steps to ensure proper direction and zero position configuration. 1Ô∏è‚É£ Encoder Direction You\'ll need to make sure your encoder is configured correctly. With the device facing you, as shown in the following picture, please make sure that the encoder position increases as you rotate the arm counterclockwise. Expected Behavior: ‚Ä¢ Counterclockwise rotation ‚Üí Position increases ‚Ä¢ Clockwise rotation ‚Üí Position decreases üîß Implementation Sequence Rotate Counter-Clockwise Manually rotate the mechanism counter-clockwise and observe if the encoder position increases. Fix Direction if Needed If position goes down instead of up, go to "Info" ‚Üí "Sensor Direction" ‚Üí press "Apply" button to invert the encoder direction. Zero the Encoder Put arm to zero position, then in TunerX go to "Info" ‚Üí press "0 encoder" button ‚Üí press "Apply" button. 2Ô∏è‚É£ Verifying Motor Setup You\'ll want to make sure your motor is spinning in the expected direction. If the motor is getting positive voltage, it should be spinning counterclockwise. You can check this through tuner, with the device facing you as in the following picture. üîß Motor Direction Verification Expected: Positive voltage should move the mechanism in the "positive" direction (counter-clockwise for arms). Positive motor voltage ‚Üí positive encoder change, negative motor voltage ‚Üí negative encoder change. ) : ( 1Ô∏è‚É£ Verifying Motor Setup You\'ll want to make sure your flywheel motors are spinning in the expected direction. If the motor is getting positive voltage, both motors should spin in the same direction (leader-follower setup). You can check this through tuner. ‚Ä¢ Leader and follower motors spin together ‚Ä¢ Positive voltage ‚Üí Shooting Both motors should rotate smoothly in the same direction with consistent speed. Follower motor should mirror leader motor movements with minimal lag. ‚úÖ Ready for Control Once your mechanism moves in the correct direction and provides accurate feedback (encoder for arms, motor consistency for flywheels), you\'re ready to implement advanced control algorithms. üí° Next Step: With verified hardware setup, we can now implement PID control for precise mechanism control. The control algorithm will use sensor feedback to automatically reach target positions or velocities. use client arm flywheel Mechanism Setup /running-program Running Program /pid-control PID Control Mechanism Setup - Verifying Hardware Configuration Before implementing advanced control algorithms, we need to verify that motors and encoders are working correctly. This ensures proper direction, zeroing, and basic functionality. Always verify hardware setup before adding control algorithms. Otherwise you will be debugging control issues when the problem is hardware configuration. bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-6 flex items-start gap-3 w-6 h-6 text-red-600 dark:text-red-400 flex-shrink-0 mt-0.5 none currentColor 0 0 24 24 round M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z text-lg font-bold text-red-800 dark:text-red-300 mb-2 text-red-700 dark:text-red-300 mb-3 bg-red-100 dark:bg-red-900/30 p-3 rounded border border-red-200 dark:border-red-700 text-red-800 dark:text-red-200 text-sm flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 card border-b border-[var(--border)] flex border-primary-600 text-primary-600 border-transparent text-[var(--muted-foreground)] hover:text-[var(--foreground)] p-6 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6 flex items-start gap-4 w-6 h-6 text-blue-600 dark:text-blue-400 flex-shrink-0 mt-1 M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z text-lg font-bold text-blue-800 dark:text-blue-300 mb-2 text-blue-700 dark:text-blue-300 card p-8 text-2xl font-bold text-[var(--foreground)] mb-6 grid grid-cols-2 gap-6 mb-6 text-[var(--muted-foreground)] mb-4 bg-primary-50 dark:bg-primary-950/30 p-4 rounded-lg font-semibold text-primary-900 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300 space-y-1 text-sm flex flex-row gap-8 justify-center items-center mb-8 /images/setup/unit_circle_degrees_rotations_decimal.png Unit circle showing counterclockwise rotation direction rounded-lg /images/setup/counter-clockwise.png Counterclockwise rotation direction text-xl font-bold text-[var(--foreground)] mb-4 space-y-4 flex items-center gap-4 p-4 bg-primary-50 dark:bg-primary-950/20 rounded-lg bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-700 dark:text-primary-300 text-primary-600 dark:text-primary-400 text-sm flex items-center gap-4 p-4 bg-primary-100 dark:bg-primary-900/30 rounded-lg bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-800 dark:text-primary-200 text-primary-700 dark:text-primary-300 text-sm flex items-center gap-4 p-4 bg-primary-200 dark:bg-primary-800/40 rounded-lg bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-900 dark:text-primary-100 text-primary-800 dark:text-primary-200 text-sm https://www.youtube.com/embed/mjGn3y19eUc Encoder Setup and Verification accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full aspect-video rounded-lg grid grid-cols-2 gap-6 mb-8 items-start text-[var(--muted-foreground)] Counterclockwise rotation direction for motor verification rounded-lg -mt-0 https://www.youtube.com/embed/iQqR1Wxptzg Motor Testing mt-8 text-xl font-bold text-learn-600 mb-4 grid md:grid-cols-2 gap-6 Positive Voltage Test Apply +6V to your motor and observe movement direction. bg-[var(--muted)] text-[var(--muted-foreground)] p-3 rounded border border-[var(--border)] text-xs text-[var(--muted-foreground)] Encoder Consistency Verify encoder readings match motor movement. grid grid-cols-3 gap-6 mb-8 col-span-2 flex w-full justify-center /images/mechanisms/flywheel.png Flywheel mechanism for motor verification Apply +6V to your flywheel and observe rotation. Leader-Follower Check Verify follower motor tracks leader motor exactly. bg-[var(--muted)] border border-[var(--border)] rounded-lg p-6 bg-indigo-50 dark:bg-indigo-950/30 p-4 rounded mt-4 text-indigo-800 dark:text-indigo-300 text-sm',
    url: "/mechanism-setup",
    category: "Workshop 1",
    tags: ["mechanism-setup", "hardware", "robot", "motor", "control", "pid"],
  },
  {
    id: "motion-magic",
    title: "Motion Magic",
    description:
      "Advanced motion profiling using CTRE's Motion Magic for smooth, controlled movements.",
    content:
      'Understanding Motion Magic Profiles üìà Trapezoidal Profile Motion Magic creates a trapezoidal velocity profile with three phases: 1. Acceleration: 2. Cruise: 3. Deceleration: ‚öôÔ∏è Key Parameters Motion Magic Cruise Velocity Maximum velocity during cruise phase (rotations/second) Motion Magic Acceleration Rate of acceleration/deceleration (rotations/second¬≤) Motion Magic Jerk Rate of change of acceleration (rotations/second¬≥) üìö Official Motion Magic Documentation For complete Motion Magic reference, configuration examples, and advanced tuning techniques: ü¶æ Position Mechanisms (Arms, Elevators) 1. Calculate Maximum Velocity: Motor Speed: Krakens run around 100 RPS at maximum Efficiency: Best used around 80% efficiency Gear Ratio: Our 25:1 arm gearing reduces speed maxVel = (100 / 25) * 0.8 = 3.2 RPS 2. Set Motion Magic Parameters: Cruise Velocity: Use calculated max velocity cruiseVel = 3.0; // conservative start Acceleration: Start with 2x cruise velocity for smooth motion Competition: Typically end up with 4x to 10x cruise velocity acceleration = cruiseVel * 2.0; // smooth start üå™Ô∏è Velocity Mechanisms (Flywheels, Shooters) Direct Drive: Using Kraken encoder directly on flywheel cruiseVel = 100 * 0.8 = 80 RPS cruiseVel = 80.0; // based on motor efficiency üí° Why This Method Works: By calculating cruise velocity based on motor specifications and efficiency, you set realistic motion limits that prevent oscillation and ensure smooth, achievable motion profiles. Starting with 2x acceleration provides smooth motion, while competition applications often require 4x to 10x cruise velocity for faster response. üìπ Motion Magic Tuning Tutorial Watch this comprehensive tutorial on Motion Magic tuning techniques, parameter selection, and optimization strategies: Motion Magic Implementation in Code 25:1 Gearing: Krakens run ~100 RPS, so 4 RPS theoretical max at output", "‚Ä¢ Cruise Velocity (2.0): Conservative start - can reach 4 RPS but load may reduces performance", "‚Ä¢ Acceleration (8.0): How quickly to reach cruise speed", "‚Ä¢ Jerk (80.0): Smoothness of acceleration changes", "‚Ä¢ MotionMagicVoltage: Replaces PositionVoltage for profiled control", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ Setpoint Detection: Checks both position AND velocity", "‚Ä¢ Smooth Motion: Eliminates jerky arm movements", "‚Ä¢ Mechanical Safety: Reduces stress on gearboxes", "‚Ä¢ Predictable Timing: How quickly to reach target velocity", "‚Ä¢ Jerk: MotionMagicVelocity: Replaces VelocityVoltage for profiled control", "‚Ä¢ Velocity Targeting: Precise speed control with smooth ramping", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ Checks both velocity AND acceleration", "‚Ä¢ Eliminates sudden flywheel speed changes", "‚Ä¢ Reduces stress on motors and mechanisms", "‚Ä¢ When to Use Basic PID: Simple positioning tasks Continuous control (like maintaining angle) When speed of response is critical Mechanisms with very low inertia When to Use Motion Magic: Large, heavy mechanisms (arms, elevators) When smooth motion is important Preventing mechanical stress Predictable motion timing needed Motion Magic /pid-control PID Control /vision-shooting Vision-Based Shooting Motion Magic - Profiled Motion Control Motion Magic builds on PID control by adding smooth acceleration and deceleration profiles. This prevents jerky movements and reduces mechanical stress while maintaining precise positioning. Motion Magic automatically generates smooth velocity profiles to reach target positions with controlled acceleration. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-2 gap-6 bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-xl font-bold text-[var(--foreground)] mb-4 text-[var(--foreground)] mb-4 text-sm space-y-2 bg-slate-50 dark:bg-slate-900 p-3 rounded text-[var(--foreground)] text-[var(--muted-foreground)] text-sm bg-[var(--muted)] rounded-lg p-6 border-l-4 border-blue-500 space-y-3 font-bold text-[var(--foreground)] text-[var(--foreground)] mb-4 https://v6.docs.ctr-electronics.com/en/latest/docs/api-reference/device-specific/talonfx/motion-magic.html CTRE Motion Magic API Reference w-5 h-5 ‚öôÔ∏è Motion Magic Tuning Steps info bg-blue-50 dark:bg-blue-950 p-4 rounded-lg border border-blue-200 dark:border-blue-800 font-semibold text-blue-800 dark:text-blue-200 mb-3 flex items-center space-y-4 font-semibold text-[var(--foreground)] mb-2 text-sm text-[var(--foreground)] space-y-2 list-disc list-inside bg-slate-50 dark:bg-slate-800 px-1 rounded bg-green-50 dark:bg-green-950 p-4 rounded-lg border border-green-200 dark:border-green-800 font-semibold text-green-800 dark:text-green-200 mb-3 flex items-center bg-[var(--muted)] p-4 rounded mt-4 border-l-4 border-[var(--border)] text-[var(--foreground)] text-sm flex flex-col gap-6 text-2xl font-bold text-slate-900 dark:text-slate-100 aspect-video rounded-lg overflow-hidden https://www.youtube.com/embed/7I7r9p1RBZI Motion Magic Tuning Tutorial w-full h-full üîß Motion Magic Configuration Example java Motion Magic Setup in Subsystem Constructor Workshop Implementation: Motion Magic ‚Ä¢ PID position control with PositionVoltage ‚Ä¢ Instant acceleration to target ‚Ä¢ Potential mechanical stress from jerky movements ‚Ä¢ No velocity planning or profiling ‚Ä¢ Abrupt start/stop motions ‚Ä¢ Motion Magic profiled motion with MotionMagicVoltage ‚Ä¢ Smooth acceleration and deceleration curves ‚Ä¢ Reduced mechanical stress and wear ‚Ä¢ Configurable cruise velocity and acceleration ‚Ä¢ Professional, smooth motion profiles Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 4-MotionMagic Arm.java Motion Magic Example Params for 25:1 Arm ‚Ä¢ <strong>25:1 Gearing:</strong> Krakens run ~100 RPS, so 4 RPS theoretical max at output ‚Ä¢ <strong>Cruise Velocity (2.0):</strong> Conservative start - can reach 4 RPS but load may reduces performance ‚Ä¢ <strong>Acceleration (8.0):</strong> How quickly to reach cruise speed ‚Ä¢ <strong>Jerk (80.0):</strong> Smoothness of acceleration changes ‚Ä¢ <strong>MotionMagicVoltage:</strong> Replaces PositionVoltage for profiled control Enhanced Features ‚Ä¢ <strong>Setpoint Detection:</strong> Checks both position AND velocity ‚Ä¢ <strong>Smooth Motion:</strong> Eliminates jerky arm movements ‚Ä¢ <strong>Mechanical Safety:</strong> Reduces stress on gearboxes ‚Ä¢ <strong>Predictable Timing:</strong> Known motion duration Motion Magic gives us professional-grade position control! Next, we ‚Ä¢ PID velocity control with VelocityVoltage ‚Ä¢ Instant acceleration to target speed ‚Ä¢ Potential mechanical stress from sudden velocity changes ‚Ä¢ Motion Magic profiled velocity with MotionMagicVelocity ‚Ä¢ Configurable acceleration and jerk for velocity changes ‚Ä¢ Professional, smooth velocity transitions src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java Motion Magic Parameters ‚Ä¢ <strong>Acceleration:</strong> How quickly to reach target velocity ‚Ä¢ <strong>Jerk:</strong> Smoothness of acceleration changes ‚Ä¢ <strong>MotionMagicVelocity:</strong> Replaces VelocityVoltage for profiled control ‚Ä¢ <strong>Velocity Targeting:</strong> Precise speed control with smooth ramping ‚Ä¢ <strong>Setpoint Detection:</strong> Checks both velocity AND acceleration ‚Ä¢ <strong>Smooth Motion:</strong> Eliminates sudden flywheel speed changes ‚Ä¢ <strong>Mechanical Safety:</strong> Reduces stress on motors and mechanisms ‚Ä¢ <strong>Predictable Timing:</strong> Known velocity change duration Motion Magic gives us professional-grade velocity control! Next, we ‚öñÔ∏è Motion Magic vs Basic PID warning text-sm text-[var(--foreground)] space-y-1 list-disc list-inside',
    url: "/motion-magic",
    category: "Workshop 1",
    tags: [
      "motion-magic",
      "motor",
      "control",
      "pid",
      "ctre",
      "java",
      "subsystem",
      "workshop",
      "frc",
      "robot",
    ],
  },
  {
    id: "home",
    title: "Gray Matter Coding Workshop - Home",
    description:
      "Learn FRC's best programming practices to build a robot good enough to win events.",
    content:
      "Hemlock's Gray Matter - Team 5712 Coding Workshop Learn FRC's best programming practices to build a robot good enough to win events. Master code architecture, subsystems, PID tuning, libraries, and more! Ready to build competition-winning robot code? Begin Your FRC Journey Hands-on ¬∑ Interactive What We're Programming This workshop uses two fundamental FRC mechanisms to teach universal programming concepts that apply to all robot systems. Learn motor control, PID tuning, encoder feedback, and motion profiling with these competition-proven designs. Arm Position Control Program precise arm positioning using PID control, encoder feedback, and Motion Magic for smooth, controlled movements to scoring positions. Flywheel Velocity Control Master velocity control for consistent shooting performance using feedforward control and velocity PID for rapid spin-up and accuracy. Special thanks to: The Team: Joe Lockwood, Josh Bacon, Chris Bale, Alex Haltom, and Team 5712 Ethan Shannon and Team 5216 max-w-6xl mx-auto px-4 py-12 flex flex-col gap-8 text-center flex flex-col gap-8 text-3xl md:text-4xl font-bold text-slate-900 dark:text-slate-100 text-center text-xl text-slate-600 dark:text-slate-300 max-w-3xl mx-auto max-w-lg mx-auto text-center text-slate-600 dark:text-slate-400 mb-6 text-lg /introduction inline-flex flex-col items-center bg-primary-600 text-white px-12 py-5 rounded-xl font-bold hover:bg-primary-700 transition-all duration-200 transform hover:scale-105 shadow-lg hover:shadow-xl text-2xl text-sm font-normal opacity-90 mt-1 bg-slate-50 dark:bg-slate-900 rounded-lg p-8 shadow-lg border border-slate-200 dark:border-slate-800 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-6 text-center text-slate-600 dark:text-slate-300 text-center mb-4 max-w-3xl mx-auto text-slate-600 dark:text-slate-300 text-center mb-8 max-w-3xl mx-auto grid md:grid-cols-2 gap-8 bg-white dark:bg-slate-800 rounded-lg p-6 shadow-md border border-slate-200 dark:border-slate-700 mb-4 /images/mechanisms/arm.png Competition robot arm with rotational joint controlled by CTRE Kraken motor, demonstrating position control for FRC scoring mechanisms w-full h-48 object-cover rounded-lg shadow-sm bg-primary-100 dark:bg-primary-900/20 p-4 rounded-lg text-xl font-semibold text-primary-900 dark:text-primary-300 mb-2 text-primary-700 dark:text-primary-300 text-sm /images/mechanisms/flywheel.png High-speed flywheel shooter mechanism for launching game pieces, demonstrating velocity control and feedforward techniques in FRC bg-green-100 dark:bg-green-900/20 p-4 rounded-lg text-xl font-semibold text-green-900 dark:text-green-300 mb-2 text-green-700 dark:text-green-300 text-sm bg-[var(--card)] text-[var(--foreground)] p-8 rounded-lg text-center space-y-6 space-y-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 items-center justify-items-center https://store.ctr-electronics.com/ _blank noopener noreferrer w-full max-w-48 h-32 flex items-center justify-center bg-white dark:bg-slate-800 rounded-lg p-2 shadow-sm hover:shadow-md transition-shadow cursor-pointer /images/sponsors/ctre-logo.jpg CTR Electronics Logo max-w-full max-h-full object-contain https://michauto.org/ /images/sponsors/MichAuto Logo 600x600.png MichAuto Logo https://www.michiganbusiness.org/ofme/ /images/sponsors/OFME-Logo.png Michigan Office of Future Mobility and Electrification Logo https://lockwoodstemcenter.hemlockps.com/home /images/sponsors/lockwood-stem-center-logo.png Lockwood STEM Center Logo text-lg font-semibold text-slate-900 dark:text-slate-100 mb-2 text-slate-600 dark:text-slate-300",
    url: "/",
    category: "General",
    tags: ["workshop", "frc", "robot", "pid", "motor", "control", "ctre"],
  },
  {
    id: "pathplanner",
    title: "Adding PathPlanner",
    description:
      "Integrating PathPlanner for autonomous path planning and trajectory following.",
    content:
      "The swerve drivetrain generated by Phoenix Tuner X doesn't include the PathPlanner integration by default. The Workshop-Code repository includes this integration in Pull Request #7, which shows the complete swerve and PathPlanner setup. Workshop Code Implementation SwerveWithPathPlanner The swerve code includes several key files generated by Phoenix Tuner X: CommandSwerveDrivetrain: Main drivetrain subsystem with control methods TunerConstants: All configuration values (CAN IDs, gear ratios, dimensions) RobotContainer: Drive command bindings and controller setup generated/ folder: Low-level module and drive train implementations What is PathPlanner? PathPlanner is a motion planning tool specifically designed for FRC robots. It provides a graphical interface for creating autonomous paths with velocity constraints, rotation control, and event markers. Key Features Visual Path Editor: Drag-and-drop waypoints on a field image Holonomic Support: Independent control of translation and rotation Constraints: Velocity, acceleration, and angular velocity limits Event Markers: Trigger commands at specific points along the path Named Commands: Reusable command definitions for autonomous Auto Builder: Compose complex autos from multiple paths Why PathPlanner? FRC-Specific: Built for WPILib and FRC field layouts Time-Saving: Visual editor is faster than manual tuning Repeatable: Paths saved as JSON files in your repo Team Friendly: Non-programmers can help create paths Proven: Used by top FRC teams in competition Active Development: Regular updates and FRC community support Installing PathPlanner Step 1: Download PathPlanner GUI Download the PathPlanner desktop application for your operating system from the official releases page: Step 2: Add PathPlanner as a Vendor Dependency Follow the steps in the PathPlanner Getting Started Guide to add PathPlanner as a vendor dependency. Step 3: Configure AutoBuilder The CommandSwerveDrivetrain generated by Phoenix Tuner X automatically configures PathPlanner's AutoBuilder. You can see this in the constructor: Creating Your First Path Opening Your Project in PathPlanner Launch the PathPlanner GUI application Click \"Open Project\" and navigate to your robot project root directory src/main/deploy/pathplanner directory Update robot configuration in the PathPlanner settings to match your robot's physical parameters Path Creation Workflow Add Waypoints: Click on the field to place waypoints. The first point is your starting position, and subsequent points define the path. Adjust Heading: For swerve drive, you can independently control the robot's heading at each waypoint. Drag the rotation handle to set the desired orientation. Set Constraints: Define velocity and acceleration limits for different segments of the path. This is useful for slowing down around tight turns. Add Event Markers: Place markers along the path to trigger commands (e.g., intake game pieces, shoot, etc.) NamedCommands Register named commands that can be triggered by event markers in your paths: PathPlanner Tips & Best Practices Start with simple paths and gradually add complexity Use fewer waypoints for smoother paths (let PathPlanner interpolate) Test paths in simulation before running on real robot Save multiple versions of paths for testing different strategies Don't set constraints too aggressively - allow margins for error Always verify starting pose matches path starting point deploy/pathplanner Test event marker timing - they execute at specific path points PathPlanner Integration Complete! You now have PathPlanner integrated with your swerve drivetrain and understand how to create autonomous paths. Key takeaways: PathPlanner provides visual path creation for autonomous routines CTRE swerve generator automatically configures PathPlanner integration Holonomic support allows independent translation and rotation Event markers enable command execution at specific path points Named commands create reusable actions for autonomous Workshop Code PRs demonstrate progressive implementation What's Next? Up Next: Logging Options With autonomous paths configured, you'll learn about data logging strategies to capture telemetry and debug your robot's performance. Adding PathPlanner /swerve-drive-project Creating a Swerve Drive Project /logging-options Logging Options PathPlanner for Autonomous Navigation PathPlanner is a motion profile generator for FRC robots, providing a GUI for creating complex autonomous paths and seamlessly integrating with your swerve drivetrain. The CTRE swerve generator automatically configures PathPlanner integration, making autonomous development straightforward. PathPlanner enables visual path creation with constraints, events, and holonomic control for swerve drivetrains. info PathPlanner Integration mb-2 flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 text-primary-600 underline hover:no-underline hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300 font-medium https://github.com/CrossTheRoadElec/Phoenix6-Examples/tree/main/java/SwerveWithPathPlanner üìÅ CommandSwerveDrivetrain.java space-y-4 Hemlock5712/Workshop-Code 1-Swerve src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java üéÆ RobotContainer.java src/main/java/frc/robot/RobotContainer.java üîç Exploring the Swerve Implementation mb-3 list-disc list-inside space-y-2 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 gap-6 bg-primary-50 dark:bg-primary-950/30 p-6 rounded-lg border border-slate-200 dark:border-slate-800 text-lg font-semibold text-slate-900 dark:text-slate-100 mb-4 space-y-2 text-sm text-slate-600 dark:text-slate-300 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 space-y-6 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-4 text-slate-600 dark:text-slate-300 mb-4 https://github.com/mjansen4857/pathplanner/releases PathPlanner Releases https://pathplanner.dev/pplib-getting-started.html PathPlanner Installation Guide CommandSwerveDrivetrain.java java Failed to load PathPlanner config and configure AutoBuilder space-y-3 text-slate-600 dark:text-slate-300 mb-4 https://pathplanner.dev/robot-config.html PathPlanner Settings space-y-4 text-slate-600 dark:text-slate-300 font-semibold mb-2 text-sm Registered Named Commands intakeNote shootNote stopIntake tip Path Creation list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 warning Common Pitfalls bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4 https://pathplanner.dev/home.html PathPlanner Official Documentation",
    url: "/pathplanner",
    category: "Workshop 2",
    tags: [
      "pathplanner",
      "workshop",
      "subsystem",
      "control",
      "command",
      "frc",
      "robot",
      "ctre",
      "java",
    ],
  },
  {
    id: "pid-control",
    title: "PID Control",
    description:
      "Understanding and implementing PID control for precise robot positioning and movement.",
    content:
      'Understanding PID Components P - Proportional Definition: "The amount of output to apply per unit of error in the system" Error = Target - Current P_Output = kP √ó Error Behavior: Larger error = stronger correction. Provides immediate response but may cause oscillation. I - Integral "The amount of output to apply per unit of error for every second of that error" Accumulated_Error += Error √ó dt I_Output = kI √ó Accumulated_Error Eliminates steady-state error by accumulating past errors over time. Note: The integral term can lead to "windup," which may make your mechanism unstable. In most FRC applications, you can leave the integral term at zero. D - Derivative "The amount of output to apply per change in error over time" Error_Rate = (Error - Last_Error) / dt D_Output = kD √ó Error_Rate Reduces overshoot by predicting future error trends and dampening response. Feedforward gains help the system by predicting the required output based on the target, rather than reacting to error. Constant output to overcome friction and get the mechanism moving. Compensates for gravitational forces acting on the mechanism. Output applied per target velocity to maintain smooth motion. Output applied per target acceleration for responsive movement. For detailed PID tuning instructions, step-by-step processes, and mechanism-specific guidance: üìπ PID and Feedforward Tuning Tutorial Watch this comprehensive tutorial on PID and feedforward tuning techniques, practical tuning steps, and optimization strategies: PID Implementation in Code PositionVoltage: Replaces VoltageOut for closed-loop control", "‚Ä¢ Slot0 Config: PID and feedforward gains configuration", "‚Ä¢ Target Setting: setTargetPosition() method for precise control", ], rightTitle: "Gain Values Used", rightItems: [ "‚Ä¢ kP = 24.0: Strong proportional response", "‚Ä¢ kD = 0.1: Small derivative for damping", "‚Ä¢ kS = 0.25: Static friction compensation", "‚Ä¢ kG = 0.12: VelocityVoltage: Replaces VoltageOut for closed-loop velocity control", "‚Ä¢ PID and feedforward gains configuration for velocity", "‚Ä¢ setTargetVelocity() method for precise speed control", ], rightTitle: "Gain Values Used", rightItems: [ "‚Ä¢ kP: Proportional response for velocity error", "‚Ä¢ kI: Integral gain to eliminate steady-state velocity error", "‚Ä¢ kS: Static friction compensation for startup", "‚Ä¢ kV: PID Control /mechanism-setup Mechanism Setup /motion-magic Motion Magic PID Control - Precise Position Control PID (Proportional-Integral-Derivative) control replaces imprecise voltage commands with accurate, feedback-driven position control. Essential for mechanisms that need to hit specific targets. PID uses sensor feedback to automatically adjust motor output to reach and maintain target positions. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-3 gap-6 bg-[var(--muted)] dark:bg-slate-700/20 rounded-lg p-6 border-l-4 border-red-500 text-xl font-bold text-[var(--foreground)] mb-4 text-[var(--foreground)] mb-4 text-sm bg-[var(--muted)] text-[var(--muted-foreground)] p-4 rounded mb-3 text-xs text-[var(--foreground)] text-sm bg-[var(--muted)] dark:bg-slate-700/20 rounded-lg p-6 border-l-4 border-yellow-500 text-[var(--foreground)] text-sm mb-3 bg-[var(--muted)] dark:bg-slate-700/20 rounded-lg p-6 border-l-4 border-blue-500 info ‚ö° Feedforward Gains mb-4 grid md:grid-cols-4 gap-4 kS - Static Always kG - Gravity Arms/Elevators kV - Velocity Flywheels/Intakes kA - Acceleration High Inertia Mechanisms üìö Complete PID Tuning Guide https://phoenixpro-documentation--161.org.readthedocs.build/en/161/docs/application-notes/manual-pid-tuning.html CTRE Manual PID Tuning Guide w-5 h-5 flex flex-col gap-6 text-2xl font-bold text-slate-900 dark:text-slate-100 bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-[var(--foreground)] mb-4 aspect-video rounded-lg overflow-hidden https://www.youtube.com/embed/Pt7SBFfl3oM PID and Feedforward Tuning Tutorial w-full h-full üîß PID Configuration Example java PID Setup in Subsystem Constructor Workshop Implementation: PID Control ‚Ä¢ Commands control Arm with voltage ‚Ä¢ No position feedback control ‚Ä¢ Imprecise, inconsistent movement ‚Ä¢ No automatic target reaching ‚Ä¢ Manual voltage adjustment needed ‚Ä¢ PID position control with PositionVoltage ‚Ä¢ Automatic target position reaching ‚Ä¢ Precise, repeatable movements ‚Ä¢ Feedforward compensation for gravity ‚Ä¢ Tolerance checking for Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 3-PID Arm.java PID Implementation ‚Ä¢ <strong>PositionVoltage:</strong> Replaces VoltageOut for closed-loop control ‚Ä¢ <strong>Slot0 Config:</strong> PID and feedforward gains configuration ‚Ä¢ <strong>Target Setting:</strong> setTargetPosition() method for precise control Gain Values Used ‚Ä¢ <strong>kP = 24.0:</strong> Strong proportional response ‚Ä¢ <strong>kD = 0.1:</strong> Small derivative for damping ‚Ä¢ <strong>kS = 0.25:</strong> Static friction compensation ‚Ä¢ <strong>kG = 0.12:</strong> Gravity feedforward for Arm PID gives us precise position control! In the next section, we ‚Ä¢ Commands control Flywheel with voltage ‚Ä¢ No velocity feedback control ‚Ä¢ Inconsistent speed control ‚Ä¢ No automatic velocity targeting ‚Ä¢ PID velocity control with VelocityVoltage ‚Ä¢ Automatic target velocity reaching ‚Ä¢ Consistent, repeatable speeds ‚Ä¢ Feedforward compensation for friction ‚Ä¢ Velocity tolerance checking for src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>VelocityVoltage:</strong> Replaces VoltageOut for closed-loop velocity control ‚Ä¢ <strong>Slot0 Config:</strong> PID and feedforward gains configuration for velocity ‚Ä¢ <strong>Target Setting:</strong> setTargetVelocity() method for precise speed control ‚Ä¢ <strong>kP:</strong> Proportional response for velocity error ‚Ä¢ <strong>kI:</strong> Integral gain to eliminate steady-state velocity error ‚Ä¢ <strong>kS:</strong> Static friction compensation for startup ‚Ä¢ <strong>kV:</strong> Velocity feedforward for smooth operation PID gives us precise velocity control! In the next section, we',
    url: "/pid-control",
    category: "Workshop 1",
    tags: [
      "pid-control",
      "pid",
      "frc",
      "control",
      "motor",
      "ctre",
      "java",
      "subsystem",
      "workshop",
      "robot",
    ],
  },
  {
    id: "prerequisites",
    title: "Prerequisites",
    description:
      "Required software and hardware setup before starting the workshop.",
    content:
      "üìã Software Requirements WPILib Game Tools Install WPILib VS Code and National Instruments Game Tool (includes Driver Station and roboRIO imaging). Phoenix Tuner X Essential for configuring and tuning TalonFX and other CTRE hardware. Git Use Git for version control. Summarize changes clearly (e.g., 'Add drivetrain PID tuning logic'). PathPlanner Allows you to draw paths for your swerve drive to follow. Elastic Dashboard Drivers use a dashboard to easily view the robot and key items, such as selecting autonomous routines or viewing motor errors. Java Knowledge Ideally, some basic knowledge of Java coding (optional but recommended). Ready to Start? Make sure you have all the prerequisites installed before proceeding to the hardware setup section. Prerequisites /introduction Introduction /mechanism-cad Mechanism CAD grid gap-6 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-4 space-y-6 border-l-4 border-purple-200 dark:border-purple-900 pl-4 text-lg font-semibold text-slate-900 dark:text-slate-100 https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-2/wpilib-setup.html text-purple-600 underline hover:no-underline dark:text-purple-400 _blank noopener noreferrer https://www.ni.com/en/support/downloads/drivers/download.frc-game-tools.html#553883 text-slate-600 dark:text-slate-300 mt-2 border-l-4 border-blue-200 dark:border-blue-900 pl-4 https://apps.microsoft.com/detail/9NVV4PWDW27Z text-blue-600 underline hover:no-underline dark:text-blue-400 border-l-4 border-green-200 dark:border-green-900 pl-4 https://git-scm.com/downloads text-green-600 underline hover:no-underline dark:text-green-400 border-l-4 border-orange-200 dark:border-orange-900 pl-4 https://github.com/mjansen4857/pathplanner/releases text-orange-600 underline hover:no-underline dark:text-orange-400 border-l-4 border-red-200 dark:border-red-900 pl-4 https://github.com/Gold872/elastic-dashboard text-red-600 underline hover:no-underline dark:text-red-400 border-l-4 border-yellow-200 dark:border-yellow-900 pl-4 https://www.codecademy.com/learn/learn-java text-yellow-600 underline hover:no-underline dark:text-yellow-400 bg-primary-50 dark:bg-primary-950/30 border border-primary-200 dark:border-primary-900 rounded-lg p-6 mb-8 text-lg font-semibold text-primary-700 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300",
    url: "/prerequisites",
    category: "Getting Started",
    tags: [
      "prerequisites",
      "ctre",
      "hardware",
      "control",
      "pid",
      "robot",
      "motor",
      "java",
      "frc",
    ],
  },
  {
    id: "project-setup",
    title: "Project Setup",
    description:
      "Creating a new WPILib project and configuring it for CTRE hardware integration.",
    content:
      'Creating a New WPILib Project Follow these step-by-step instructions to create a new FRC robot project using the Command Robot Skeleton (Advanced) template. Open VSCode Launch Visual Studio Code with the WPILib extension installed. Select the WPILib Logo in Top Right Corner Click on the WPILib logo/icon in the top right corner of VSCode. Select "Create a New Project" From the WPILib menu, choose the "Create a new project" option. Select "Select a project type (Example or Template)" Command Robot Skeleton (Advanced) Base folder select "Downloads" OneDrive locations are not supported and will cause project creation to fail. Project Name "Workshop" Enter "Workshop" as your project name. Team Number Enter your FRC team number. This is required for deploying code to your robot. Check "Enable Desktop Support" This allows you to test your robot code on your computer without a robot. Generate Project Click "Generate Project" and then open the new project when prompted. After creating your project, you\'ll learn about the Command-Based Framework in the next section. Your project will be ready for implementing subsystems and commands! Project Setup /hardware Hardware Setup /command-framework Command-Based Framework Project Setup - Launching Your Codebase Step-by-step guide to generating a new WPILib project using the Command framework template. Starting with the right template ensures organized commands and subsystems. bg-slate-50 dark:bg-slate-900 rounded-lg p-8 shadow-lg border border-slate-200 dark:border-slate-800 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-6 text-slate-600 dark:text-slate-300 mb-6 space-y-4 flex items-start space-x-3 bg-primary-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold font-medium text-slate-600 dark:text-slate-300 text-sm warning ‚ö†Ô∏è Warning mt-2 https://www.youtube.com/embed/Y8ExsyaCC34 Project Setup Tutorial accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full h-full aspect-video rounded-lg tip üí° Next Step mt-4',
    url: "/project-setup",
    category: "Workshop 1",
    tags: ["project-setup", "frc", "robot", "command", "workshop", "hardware"],
  },
  {
    id: "running-program",
    title: "Running Program",
    description:
      "Deploying and running robot code with hardware simulation and testing.",
    content:
      'Before running Hardware Simulation code, you must OFF the "CANivore USB" setting in TunerX. This prevents conflicts between the simulation environment and physical hardware communication. Open TunerX ‚Üí Go to CANivore settings ‚Üí Disable "CANivore USB" Hardware Simulation Setup Running Program /triggers Triggers /mechanism-setup Mechanism Setup Running Program - Hardware Simulation Testing WPILib provides a powerful tool called Hardware Simulation. This allows you to run your code in the simulator, while also running motors that are connected to the CANivore. Using a CANivore also allows you to build robot applications that run directly on Windows or Linux machines. Hardware simulation eliminates the need to use a roboRIO for testing, while still allowing you to test your code on hardware. warning w-6 h-6 none currentColor 0 0 24 24 round M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z Important: CANivore USB Setting mb-3 Steps mt-3 flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 https://www.youtube.com/embed/xsR7m6ToUFE Hardware Simulation accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full h-full aspect-video rounded-lg',
    url: "/running-program",
    category: "Workshop 1",
    tags: ["running-program", "hardware", "robot"],
  },
  {
    id: "search",
    title: "search",
    description: "",
    content:
      "Search Results Loading search... max-w-4xl mx-auto mb-8 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-4 flex items-center justify-center py-12 animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 ml-2 text-slate-600 dark:text-slate-300",
    url: "/search",
    category: "General",
    tags: ["search"],
  },
  {
    id: "state-based",
    title: "State-Based Control",
    description:
      "Organizing subsystem behavior into discrete states for better code structure and maintainability.",
    content:
      'Understanding State-Based Architecture üèóÔ∏è State Pattern Benefits State-based control provides structure and predictability to subsystem behavior: Encapsulation: Maintainability: Readability: ‚öôÔ∏è State Components State Enum Defines all possible subsystem states with targets Current State Tracks which state the subsystem is currently in setState() Method Changes state and applies the new configuration State-Based Implementation in Code ArmState Enum: Defines LOW, HIGH, and BACKWARD states", "‚Ä¢ Encapsulated Targets: Each state contains its target position", "‚Ä¢ State-Specific Tolerances: Different tolerance for each position", "‚Ä¢ Current State Tracking: Always know which state the arm is in", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ setState() Method: Simple way to change arm configuration", "‚Ä¢ atState() Check: Easy validation using state-specific tolerance", "‚Ä¢ Semantic Names: Code clearly shows intent (HIGH vs 0.25 rotations)", "‚Ä¢ Extensible Design: FlywheelState Enum: Defines IDLE, SHOOTING, and INTAKE states", "‚Ä¢ Each state contains its target velocity", "‚Ä¢ Different tolerance for each mode", "‚Ä¢ Always know flywheel operating mode", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ Simple way to change flywheel mode", "‚Ä¢ Code clearly shows intent (SHOOTING vs 3000 RPM)", "‚Ä¢ Manual Control Issues: Hard-coded values scattered everywhere Difficult to maintain and modify No clear organization of configurations Prone to inconsistencies and bugs Hard to understand code intent State-Based Benefits: Centralized configuration management Easy to add and modify states Clear, semantic code that shows intent Consistent tolerance and target handling Scales well with complex behaviors üè∑Ô∏è State Naming Guidelines Use Descriptive Names: HIGH STATE_1 SHOOTING FAST STARTING_POSITION STATE_2 Group Related States: Arm: LOW, HIGH, MIDDLE, BACKWARD Flywheel: STARTING_POSITION, MID_FIELD, FULL_FIELD Elevator: INTAKE, HAND_OFF, LEVEL_4 üìã State Organization Tips Include All Necessary Data: Target position/velocity State-specific tolerance Optional: timing constraints Optional: safety limits Design for Extensibility: Start with basic states, add complexity later Use constructor parameters for flexibility Consider state transitions and validation Plan for debugging and telemetry üéØ Why This Approach Works: State-based control provides a clean separation between configuration (what the states are) and behavior (how to reach them). This makes code easier to understand, test, and maintain as your robot becomes more complex. State-Based Control /vision-shooting Vision-Based Shooting Home State-Based Control - Structured Subsystem Management State-based control organizes subsystem behavior into discrete, well-defined states. Each state encapsulates target positions, tolerances, and specific configurations, making robot code more organized and maintainable. Instead of manually setting positions and tolerances everywhere, define states that encapsulate all the information needed for each subsystem configuration. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-2 gap-6 bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-xl font-bold text-[var(--foreground)] mb-4 text-[var(--foreground)] mb-4 text-sm space-y-2 bg-slate-50 dark:bg-slate-900 p-3 rounded text-[var(--foreground)] text-[var(--muted-foreground)] text-sm bg-[var(--muted)] rounded-lg p-6 border-l-4 border-purple-500 space-y-3 font-bold text-[var(--foreground)] üîß State-Based Configuration Example java State Enum and Implementation Workshop Implementation: State-Based Control ‚Ä¢ Manual position and tolerance management ‚Ä¢ Hard-coded values scattered throughout code ‚Ä¢ Difficult to add new arm positions ‚Ä¢ No clear organization of arm configurations ‚Ä¢ Tolerance values repeated in multiple places ‚Ä¢ Well-defined states: LOW, HIGH, BACKWARD ‚Ä¢ Each state encapsulates target position and tolerance ‚Ä¢ Easy to add new states by extending the enum ‚Ä¢ Clear, readable code with semantic state names ‚Ä¢ Centralized configuration management Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 6-StateBased Arm.java State-Based Architecture ‚Ä¢ <strong>ArmState Enum:</strong> Defines LOW, HIGH, and BACKWARD states ‚Ä¢ <strong>Encapsulated Targets:</strong> Each state contains its target position ‚Ä¢ <strong>State-Specific Tolerances:</strong> Different tolerance for each position ‚Ä¢ <strong>Current State Tracking:</strong> Always know which state the arm is in Enhanced Features ‚Ä¢ <strong>setState() Method:</strong> Simple way to change arm configuration ‚Ä¢ <strong>atState() Check:</strong> Easy validation using state-specific tolerance ‚Ä¢ <strong>Semantic Names:</strong> Code clearly shows intent (HIGH vs 0.25 rotations) ‚Ä¢ <strong>Extensible Design:</strong> Add new states without changing existing code State-based control makes our arm subsystem much more organized and maintainable! This pattern scales well as we add more complex behaviors. ‚Ä¢ Manual velocity and tolerance management ‚Ä¢ Hard-coded RPM values throughout the code ‚Ä¢ Difficult to add new shooting modes ‚Ä¢ No clear organization of flywheel configurations ‚Ä¢ Tolerance values scattered in multiple places ‚Ä¢ Well-defined states: IDLE, SHOOTING, INTAKE ‚Ä¢ Each state encapsulates target velocity and tolerance ‚Ä¢ Easy to add new shooting modes by extending enum ‚Ä¢ Centralized flywheel configuration management src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>FlywheelState Enum:</strong> Defines IDLE, SHOOTING, and INTAKE states ‚Ä¢ <strong>Encapsulated Targets:</strong> Each state contains its target velocity ‚Ä¢ <strong>State-Specific Tolerances:</strong> Different tolerance for each mode ‚Ä¢ <strong>Current State Tracking:</strong> Always know flywheel operating mode ‚Ä¢ <strong>setState() Method:</strong> Simple way to change flywheel mode ‚Ä¢ <strong>Semantic Names:</strong> Code clearly shows intent (SHOOTING vs 3000 RPM) ‚Ä¢ <strong>Extensible Design:</strong> Add new modes without changing existing code State-based control makes our flywheel subsystem much more organized and maintainable! This pattern is essential for complex shooting systems. ‚öñÔ∏è State-Based vs Manual Control warning font-semibold text-[var(--foreground)] mb-2 text-sm text-[var(--foreground)] space-y-1 list-disc list-inside üí° State Design Best Practices info bg-blue-50 dark:bg-blue-950 p-4 rounded-lg border border-blue-200 dark:border-blue-800 font-semibold text-blue-800 dark:text-blue-200 mb-3 flex items-center space-y-4 text-sm text-[var(--foreground)] space-y-2 list-disc list-inside bg-slate-50 dark:bg-slate-800 px-1 rounded bg-green-50 dark:bg-green-950 p-4 rounded-lg border border-green-200 dark:border-green-800 font-semibold text-green-800 dark:text-green-200 mb-3 flex items-center bg-[var(--muted)] p-4 rounded mt-4 border-l-4 border-[var(--border)] text-[var(--foreground)] text-sm',
    url: "/state-based",
    category: "Advanced",
    tags: [
      "state-based",
      "control",
      "subsystem",
      "robot",
      "java",
      "workshop",
      "frc",
    ],
  },
  {
    id: "swerve-calibration",
    title: "swerve-calibration",
    description: "",
    content:
      "Accurate calibration ensures your robot knows exactly where it is on the field, enabling precise autonomous movement and vision integration. Below is a graphic showing the order we follow when setting up a robot. Motor Calibration Start by tuning your drive and turning motors to ensure they respond correctly to commands and maintain accurate position tracking. Tune Drive and Turning Motors Configure motor PID values, velocity/acceleration limits, and ensure proper sensor feedback. Key Calibration Steps: Make sure to read and follow Tuner X instructions carefully Verify your robot drives correct direction Tune turning motor first then move onto drive motors Stator Current Highly Recommended: Glue your drive encoders in place to prevent them from shifting during impacts or aggressive movements. Even small encoder shifts can cause significant odometry drift. Effective Wheel Radius The effective wheel radius accounts for compression, tread wear, and carpet interaction. This value is critical for accurate odometry. Wheel Radius Test Procedure Follow this systematic procedure to determine your robot's effective wheel radius. Drive Forward at Low Acceleration Command the robot to drive straight forward for a fixed distance (e.g., 3 meters) at low acceleration to minimize wheel slip. Record Sensor-Reported Distance Log the distance traveled as calculated from encoder readings. This will differ from the actual distance due to wheel compression and slip. Measure True Distance Traveled Use a tape measure to determine the actual distance the robot moved. Measure from the starting position to the final position. Calculate Rolling Radius effectiveRadius = (actualDistance / sensorDistance) * currentRadius Perform this test on the same surface you'll compete on (carpet vs. tile affects compression) Run multiple trials and average the results for better accuracy Re-calibrate if you change wheels or tread Camera Setup & Calibration Accurate camera calibration ensures vision measurements integrate correctly with your odometry, providing reliable pose estimates. Limelight Camera Configuration Set up your Limelight camera with proper positioning, focus, and calibration. Camera Setup Checklist: 1. Camera Position Configuration Enter the camera's position relative to the robot center in the Limelight web interface. Accurate position values are critical for pose estimation. 2. Camera Calibration Use a Limelight calibration board to calibrate your camera. This corrects for lens distortion and improves pose accuracy, especially at the edges of the field of view. 3. Lens Focus & Security glue the lens in place to prevent it from shifting due to vibrations. Refer to the official Limelight AprilTag documentation for detailed camera calibration instructions and best practices: PathPlanner PID Tuning PathPlanner uses PID controllers to follow autonomous paths accurately. Proper tuning ensures your robot tracks paths smoothly without oscillation or lag. PathPlanner Configuration - Do in the GUI Robot Config should be as accurate as possible to your robot, and many configs are available online. However, to significantly help path tracking, configure the App Settings, which contain the MotionMagic configurations for PathPlanner. App Setting: Max Velocity: Set to 80-90% of your robot's maximum speed. This provides headroom for PID corrections. App Setting: Max Acceleration: Conservative values (2-3 m/s¬≤) prevent wheel slip. Increase gradually while testing. App Setting: Max Angular Velocity: Limit rotational speed to prevent modules from fighting each other. App Setting: Max Angular Acceleration: Limit rotational acceleration to prevent robot from rotating too quickly. Tune PathPlanner PID values like normal. However be aware that due to loop times these cannot be tuned as aggressively. What's Next? Up Next: Vision-Based Shooting With your odometry fully calibrated, you're ready to apply vision data for automated targeting and distance-based shooting calculations. You'll learn how to use vision feedback to calculate shooter angles and velocities dynamically. Odometry Calibration /vision-implementation Implementing Vision /vision-shooting Vision-Based Shooting Calibrating Your Robot Proper calibration is the foundation of accurate autonomous performance. This includes tuning motor values, finding the effective wheel radius, configuring camera positions, and tuning PID controllers for path following. Calibration transforms theoretical parameters into real-world accuracy. text-slate-600 dark:text-slate-300 text-center -mt-4 /images/odometry-setup/Robot Flowchart.png Odometry calibration setup showing measurement procedure flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 flex items-start gap-4 mb-4 bg-primary-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 w-5 h-5 text-xl font-bold text-slate-900 dark:text-slate-100 mb-2 text-slate-600 dark:text-slate-300 mb-4 space-y-4 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 font-semibold text-slate-900 dark:text-slate-100 mb-2 list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/talonfx/improving-performance-with-current-limits.html#preventing-wheel-slip _blank noopener noreferrer text-primary-600 dark:text-primary-400 hover:underline tip üí° Encoder Security bg-green-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 bg-primary-50 dark:bg-primary-950/30 p-6 rounded-lg border border-primary-200 dark:border-primary-800 flex gap-4 bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-semibold text-slate-900 dark:text-slate-100 text-sm text-slate-600 dark:text-slate-300 mt-1 bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-primary-800 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded warning ‚ö†Ô∏è Test Conditions Matter list-disc list-inside space-y-1 text-sm bg-orange-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 font-semibold text-slate-900 dark:text-slate-100 mb-3 space-y-3 text-sm font-semibold text-slate-900 dark:text-slate-100 info üìç Limelight Documentation mb-2 https://docs.limelightvision.io/docs/docs-limelight/getting-started/performing-charuco-camera-calibration Limelight Calibration Guide text-xl font-bold text-slate-900 dark:text-slate-100 mb-4 üéØ Tuning Strategy bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/swerve-calibration",
    category: "General",
    tags: [
      "swerve-calibration",
      "robot",
      "motor",
      "pid",
      "command",
      "hardware",
    ],
  },
  {
    id: "swerve-drive-project",
    title: "Creating a Swerve Drive Project",
    description:
      "Advanced workshop on implementing swerve drive systems for omnidirectional robot movement.",
    content:
      "Swerve Drive Prerequisites Holonomic motion and swerve drive concepts Module anatomy (drive motor, azimuth motor, CANcoder) Coordinate systems (robot-centric vs field-centric) Creating a Swerve Project with Phoenix Tuner X CTRE provides a comprehensive swerve drive project generator in Phoenix Tuner X that creates a complete, competition-ready swerve drivetrain implementation. This is the recommended starting point for all swerve projects. What the Generator Creates: Complete CommandSwerveDrivetrain subsystem Tuner constants for all swerve parameters Module configurations and CAN IDs Field-centric and robot-centric drive commands Simulation support for testing without hardware PathPlanner integration for autonomous Required Information: CAN IDs for all drive motors, steer motors, encoders CANivore name (if using CANivore) Wheel diameter and gear ratios Module positions (wheelbase and trackwidth) Step-by-Step Setup Process Open Phoenix Tuner X Launch Phoenix Tuner X and connect to your robot or CANivore. Ensure all swerve motors and encoders are visible and have unique CAN IDs. Navigate to Swerve Project Generator Click on Mechanisms in the left sidebar. This will open the configuration wizard. Configure Robot Parameters Enter your robot's physical parameters: Wheelbase: Front-to-back distance between modules (meters) Trackwidth: Side-to-side distance between modules (meters) Wheel Diameter: Diameter of drive wheels (inches) Drive Gear Ratio: Motor rotations per wheel rotation Follow the Steps to Generate and Export Click New Project and follow the steps in Tuner X to set up and test your swerve drivetrain. Once you finish, click Generate Project and you'll have a completed project fully ready to deploy and drive your robot. What's Next? Up Next: PathPlanner Now that your swerve project is generated, the next step is autonomous path following with PathPlanner. Creating a Swerve Drive Project /swerve-prerequisites /pathplanner Adding PathPlanner Using Phoenix Tuner X to Generate Swerve Code With the swerve drive fundamentals covered, we s Phoenix Tuner X. This powerful tool generates production-ready swerve code, handling all the complexity of kinematics, odometry, and control. Phoenix Tuner X generates a complete, competition-ready swerve drivetrain with one configuration wizard. info Prerequisites Complete? mb-2 text-primary-600 underline hover:no-underline hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300 font-medium list-disc list-inside space-y-1 text-sm text-slate-600 dark:text-slate-300 flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 üöÄ CTRE Swerve Project Generator mb-4 grid md:grid-cols-2 gap-4 font-semibold text-slate-900 dark:text-slate-100 mb-2 space-y-6 text-2xl font-bold text-slate-900 dark:text-slate-100 space-y-4 flex items-start space-x-4 bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 flex-1 text-slate-600 dark:text-slate-300 text-slate-600 dark:text-slate-300 mb-3 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 space-y-2 text-sm text-slate-600 dark:text-slate-300 https://v6.docs.ctr-electronics.com/en/latest/docs/tuner/tuner-swerve/index.html CTRE Swerve Project Generator Documentation w-5 h-5 bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4 text-slate-600 dark:text-slate-300 mb-4",
    url: "/swerve-drive-project",
    category: "Workshop 2",
    tags: [
      "swerve-drive-project",
      "motor",
      "robot",
      "ctre",
      "subsystem",
      "hardware",
      "control",
    ],
  },
  {
    id: "swerve-prerequisites",
    title: "Swerve Drive Prerequisites",
    description:
      "Understanding swerve drive fundamentals: holonomic motion, coordinate systems, and module anatomy.",
    content:
      "Swerve Module Anatomy Each swerve module consists of three key components that work together to provide independent wheel control: Drive Motor Controls the wheel speed and provides forward/backward motion for the module. Typically a high-power motor like Kraken X60 or Falcon 500. Purpose: Translational velocity control Control: Velocity PID or voltage control Sensor: Integrated encoder for speed feedback Turning Motor Steers the module by rotating the wheel to the desired angle. Requires precise position control with absolute encoder feedback. Wheel direction control Position PID with Motion Magic Absolute encoder (CANcoder) for angle CANcoder Absolute position sensor that tracks the steering angle. Critical for module zeroing and maintaining accurate wheel orientation. Absolute angle measurement Type: WCP ThroughBore or CANcoder V2 Units: Rotations (0 to 1.0) Coordinate Systems &amp; Reference Frames Understanding coordinate systems is crucial for swerve drive control. You need to know whether movements are relative to the robot or the field. Robot-Centric (Robot Frame) All movements are relative to the robot's current orientation. Forward is always toward the front of the robot. Forward: Robot moves in the direction it's facing Strafe Right: Robot moves to its right side Use Case: Precise maneuvering, driver preference More intuitive for beginners Field-Centric (Field Frame) All movements are relative to the field. Forward is always away from your driver station, regardless of robot orientation. Robot moves away from driver station Robot moves right on the field Competition driving, intuitive control Requirement: Needs gyro for robot heading Field-centric control requires a gyroscope (IMU) to track the robot's heading. Without an accurate heading, the robot cannot determine which direction is \"forward\" relative to the field. Common gyros in FRC: Pigeon 2 (CTRE) - CAN-based, highly accurate NavX (Kauai Labs) - USB/SPI, popular choice ADIS16470 (Analog Devices) - SPI, WPILib support Swerve Kinematics &amp; Control Kinematics is the mathematical relationship between the desired robot motion (velocities in X, Y, and rotation) and the individual wheel states (speed and angle) needed to achieve that motion. üìê Forward Kinematics Converts individual wheel states into overall robot velocity. Used for odometry and determining where the robot is moving. Given: [FL, FR, BL, BR] module states Calculate: Robot velocity (Vx, Vy, omega) Example: If all modules point forward at the same speed, the robot is moving straight forward with no rotation. üìê Inverse Kinematics Converts desired robot velocity into individual wheel states. Used for teleop driving and autonomous path following. Given: Robot velocity (Vx, Vy, omega) Calculate: [FL, FR, BL, BR] module states To strafe right while rotating, inverse kinematics calculates the unique angle and speed for each module. The good news: CTRE's swerve implementation handles all kinematics calculations internally. You don't need to manually compute wheel states! The CommandSwerveDrivetrain class uses Phoenix 6's built-in kinematics to convert your desired chassis speeds (Vx, Vy, omega) into the appropriate module states automatically. Chassis speeds represent the desired velocity of the robot as a whole: Vx (Forward/Back) Linear velocity in the X direction. Positive = forward, Negative = backward. Units: meters per second. Vy (Left/Right) Linear velocity in the Y direction. Positive = left, Negative = right. Units: meters per second. Omega (Rotation) Angular velocity (rotation rate). Positive = counter-clockwise, Negative = clockwise. Units: radians per second. Odometry &amp; Pose Estimation Odometry is the process of tracking the robot's position and orientation on the field by integrating wheel movements over time. Accurate odometry is essential for autonomous navigation and field-aware control. üó∫Ô∏è Pose2d: Robot Position on the Field The robot's pose consists of three components: X Position Distance along the field length (left/right from your driver station perspective). Units: meters. Y Position Distance along the field width (forward/backward from your driver station). Units: meters. Rotation Robot heading (which direction the robot is facing). Represented as Rotation2d. 0¬∞ = field forward. The field coordinate system origin (0, 0) is at the corner of the field from your alliance's perspective. X increases to the right, Y increases forward, and rotation is counter-clockwise positive. How Odometry Works üìä Wheel Odometry Primary odometry source using encoder readings from swerve modules. Inputs: Module positions (distance traveled + angle) Process: Forward kinematics converts module deltas to robot motion Integration: Accumulates motion over time to track pose Accuracy: Drifts over time due to wheel slip and measurement errors üì∏ Vision Odometry Secondary odometry source using camera and AprilTag vision targets. Detected AprilTags with known field positions Camera calculates robot pose from tag positions Fused with wheel odometry for drift correction More accurate but only works when tags are visible CTRE's includes built-in pose estimation that fuses wheel odometry with vision measurements using a Kalman filter approach. This provides more accurate position tracking than wheel odometry alone, automatically correcting for drift when vision targets are visible. What's Next? Ready for Implementation You now understand the fundamental concepts needed for swerve drive: Holonomic motion and independent module control Module anatomy: drive motor, azimuth motor, CANcoder Coordinate systems: robot-centric vs field-centric Gyro requirements for field-centric control Critical safety practices and zeroing procedures Swerve kinematics and control Odometry Pose estimation Next, you'll learn how to use Phoenix Tuner X to generate a complete swerve project and bring up your drivetrain. Swerve Drive Prerequisites /motion-magic Motion Magic /swerve-drive-project Creating a Swerve Drive Project Understanding Swerve Drive Fundamentals Before diving into swerve drive implementation, it Master the fundamentals of swerve drive: holonomic motion, coordinate systems, module anatomy, and field-centric control. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 grid md:grid-cols-1 lg:grid-cols-3 gap-8 bg-primary-100 dark:bg-primary-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-primary-900 dark:text-primary-300 text-slate-600 dark:text-slate-300 mb-4 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 text-sm text-slate-600 dark:text-slate-300 bg-green-100 dark:bg-green-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-green-900 dark:text-green-300 bg-orange-100 dark:bg-orange-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-orange-900 dark:text-orange-300 grid md:grid-cols-2 gap-8 text-xl font-bold text-blue-900 dark:text-blue-300 mb-4 space-y-2 text-sm text-slate-600 dark:text-slate-300 text-xl font-bold text-green-900 dark:text-green-300 mb-4 info Gyro Requirement for Field-Centric mb-3 mb-2 list-disc list-inside space-y-1 text-xl font-bold text-primary-900 dark:text-primary-300 mb-4 text-xs text-slate-700 dark:text-slate-300 text-sm text-slate-600 dark:text-slate-300 mt-4 üîß CTRE Handles Kinematics Automatically üéÆ Understanding Chassis Speeds space-y-4 grid md:grid-cols-3 gap-4 bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border-l-4 border-blue-500 font-bold text-blue-900 dark:text-blue-300 mb-2 bg-green-50 dark:bg-green-900/20 p-4 rounded-lg border-l-4 border-green-500 font-bold text-green-900 dark:text-green-300 mb-2 bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg border-l-4 border-purple-500 font-bold text-purple-900 dark:text-purple-300 mb-2 java Creating Chassis Speeds for Control bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-6 grid md:grid-cols-3 gap-4 mb-6 font-bold text-primary-600 dark:text-primary-400 mb-2 tip üí° Field Coordinate System space-y-6 text-2xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-2 gap-6 text-lg font-semibold text-slate-900 dark:text-slate-100 mb-3 list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 üîÄ Pose Estimation with Sensor Fusion üìù Odometry Code Examples Getting Current Robot Pose Robot X Robot Y Robot Heading grid md:grid-cols-2 gap-4 https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-odometry.html WPILib Swerve Drive Odometry Documentation w-5 h-5 https://docs.wpilib.org/en/stable/docs/software/advanced-controls/state-space/state-space-pose-estimators.html WPILib Pose Estimators bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4 text-slate-600 dark:text-slate-300 mt-4",
    url: "/swerve-prerequisites",
    category: "Workshop 2",
    tags: [
      "swerve-prerequisites",
      "control",
      "motor",
      "pid",
      "robot",
      "frc",
      "ctre",
      "java",
    ],
  },
  {
    id: "triggers",
    title: "Triggers",
    description:
      "Binding controller inputs to commands using triggers for responsive robot control.",
    content:
      "Trigger Implementation & Examples üéØ Trigger Examples - Binding Input to Commands controller.a() &nbsp;&nbsp;.onTrue(command); Run a command once when a button is pressed or condition becomes true. The command completes its full lifecycle (initialize, execute, end). &nbsp;&nbsp;.onFalse(command); Run a command once when a button is released or condition becomes false. Perfect for stopping motors or returning to safe positions. .onTrue(cmd1) .onFalse(cmd2); Chain onTrue() and onFalse() together to define different actions for press and release, giving you full control over button behavior. new Trigger( &nbsp;&nbsp;() => sensor.get()) &nbsp;&nbsp;.onTrue(cmd); Triggers can be created from any boolean condition - sensors, limit switches, or custom logic - not just controller buttons. üîÑ Before ‚Üí After: Implementation üìã Before ‚Ä¢ Empty RobotContainer constructor ‚Ä¢ No controller declared ‚Ä¢ No configureBindings() method ‚Ä¢ Commands exist but can't be triggered ‚úÖ After ‚Ä¢ CommandXboxController instantiated ‚Ä¢ configureBindings() method created ‚Ä¢ Button triggers bound to commands ‚Ä¢ Robot responds to controller input üéØ Final Implementation & GitHub Changes üöÄ Advanced Command Patterns ‚ÑπÔ∏è Advanced Topics - Beyond This Workshop This workshop uses simplified patterns ( runOnce() onTrue() onFalse() ) for easier learning. The examples below show advanced command patterns that are powerful for competition but not required for this workshop's scope. üí° Feel free to explore these after completing the workshop fundamentals! Extending WPILib Command For more complex commands, extend Command directly instead of using inline methods. See WPILib documentation ‚Üí Complex Command Groups Combine sequences and parallel actions to coordinate subsystems. Composition Strategies Use fluent helpers to assemble commands from smaller pieces. Common Pitfalls Always declare subsystem requirements to avoid unexpected conflicts. Advanced Triggers Create triggers from sensor conditions or button combinations. Real-World Scenario Combine patterns to build robust autonomous routines. Triggers /adding-commands Commands /running-program Running Program Triggers - Connecting User Input to Commands Triggers link user inputs (buttons, joysticks, sensors) to commands. They define when and how commands should run based on controller input or robot state. Use onTrue() to run commands when buttons are pressed, and onFalse() to run commands when buttons are released. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-xl font-bold text-primary-600 mb-4 cursor-pointer hover:text-primary-700 dark:hover:text-primary-300 mt-4 java RobotContainer.java - configureBindings() grid md:grid-cols-2 gap-6 mb-6 üéÆ onTrue() Trigger üîΩ onFalse() Trigger grid md:grid-cols-2 gap-6 üîÑ Chaining Triggers üéØ Sensor Triggers text-xl font-bold text-slate-900 dark:text-slate-100 mb-4 bg-red-50 dark:bg-red-950/20 rounded-lg p-4 border border-red-200 dark:border-red-800 text-lg font-bold text-red-800 dark:text-red-300 mb-3 space-y-2 text-red-700 dark:text-red-300 text-sm bg-green-50 dark:bg-green-950/20 rounded-lg p-4 border border-green-200 dark:border-green-800 text-lg font-bold text-green-800 dark:text-green-300 mb-3 space-y-2 text-green-700 dark:text-green-300 text-sm text-lg font-bold text-slate-900 dark:text-slate-100 mb-3 Hemlock5712/Workshop-Code src/main/java/frc/robot/RobotContainer.java 2-Commands RobotContainer.java mt-4 space-y-8 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6 flex items-start gap-3 w-6 h-6 text-blue-600 dark:text-blue-400 flex-shrink-0 mt-0.5 none currentColor 0 0 24 24 round M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z text-lg font-bold text-blue-800 dark:text-blue-300 mb-2 text-blue-700 dark:text-blue-300 mb-3 bg-blue-100 dark:bg-blue-900 px-1.5 py-0.5 rounded text-sm text-sm text-blue-600 dark:text-blue-400 text-xl font-bold text-[var(--foreground)] mb-2 text-slate-600 dark:text-slate-300 mb-4 https://docs.wpilib.org/en/stable/docs/software/commandbased/commands.html#simple-command-example _blank noopener noreferrer text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 underline ml-1",
    url: "/triggers",
    category: "Workshop 1",
    tags: [
      "triggers",
      "command",
      "control",
      "robot",
      "workshop",
      "subsystem",
      "java",
      "frc",
    ],
  },
  {
    id: "vision-implementation",
    title: "Implementing Vision",
    description:
      "Practical implementation of vision systems in robot code for target detection and tracking.",
    content:
      "Vision Implementation Strategy Implementing vision requires a systematic approach to ensure reliable pose estimation. Follow these steps to integrate Limelight vision data into your robot's odometry system while maintaining accuracy and trust. üöÄ Implementation Sequence LimelightHelpers Library First, import the Limelight helper library available on GitHub. It contains pre-built NetworkTables wrappers that provide clean access to vision data without manual NetworkTables subscriptions. Limelight Subsystem Next, create a new subsystem to pull values using the Limelight helper tool. In this subsystem there are three things we need in order to add them to our pose estimator: Pose, Timestamp, and Standard Deviation (how much we will trust the reading). Both pose and timestamp are provided by LimelightHelpers, however we need to create a formula for how much to trust vision. Utilizing CTRE Pose Estimator Once we have the three values above, we can pass them into the CTRE Pose Estimator. It has pre-programmed functions that accept these values. However, we need to pass this pose estimator to the vision subsystem to add measurements. RobotContainer Setup At this point we have the pose estimator in drivetrain and now can create a vision subsystem that takes in drivetrain to add values to it. Standard Deviation Tuning As mentioned, we need a formula for how much to trust the vision reading. For this, we will use a simple formula we have used for the past two years based on tag count and distance. This formula can be significantly improved with even some simple modifications (inside field boundaries, single tag filter ambiguity, and several other checks). Library First: LimelightHelpers abstracts NetworkTables complexity. Validation Layer: The Limelight subsystem filters bad measurements before they make it to your pose estimate Dynamic Trust: Standard deviations adjust based on measurement quality, preventing bad data from degrading odometry Reading Limelight Data Limelight publishes vision data to NetworkTables. The LimelightHelpers library (provided by Limelight on GitHub) provides a clean API for reading this data without direct NetworkTables access. RobotContainer includes the setup for vision integration, showing how the Limelight subsystem connects with the swerve drivetrain and command bindings. Workshop Code Implementation The Workshop-Code repository includes complete vision implementation on the 3-Limelight branch, demonstrating Limelight integration with swerve drive and odometry. The code examples above are all taken directly from this branch, showing real working implementations you can reference and adapt for your own robot. Vision Best Practices Validate vision data before using it Account for latency (automatically done) Use appropriate standard deviations Test different exposures (lower is better) Log vision data for debugging Don't Trust vision measurements blindly Ignore latency compensation Use vision as only odometry source Forget to tune camera settings Skip testing in match conditions Additional Resources What's Next? Up Next: Odometry Calibration With vision integrated, you'll learn how to calibrate your robot's odometry for maximum accuracy, including motor tuning, wheel radius calibration, camera setup, and PathPlanner PID tuning. Implementing Vision /vision-options Vision Options /swerve-calibration Odometry Calibration Integrating Vision into Robot Code Connecting vision systems to robot code involves reading NetworkTables data, integrating AprilTag measurements into odometry, and using vision feedback for control. This section demonstrates practical vision integration patterns. Vision data transforms autonomous accuracy and enables intelligent teleop assistance. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 grid md:grid-cols-1 gap-6 text-xl font-bold text-[var(--foreground)] mb-4 space-y-4 flex items-center gap-4 p-4 bg-primary-50 dark:bg-primary-950/20 rounded-lg bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-700 dark:text-primary-300 text-primary-600 dark:text-primary-400 text-sm flex items-center gap-4 p-4 bg-primary-100 dark:bg-primary-900/30 rounded-lg bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-800 dark:text-primary-200 text-primary-700 dark:text-primary-300 text-sm flex items-center gap-4 p-4 bg-primary-200 dark:bg-primary-800/40 rounded-lg bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-900 dark:text-primary-100 text-primary-800 dark:text-primary-200 text-sm flex items-center gap-4 p-4 bg-primary-300 dark:bg-primary-700/50 rounded-lg bg-primary-800 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-950 dark:text-white text-primary-900 dark:text-primary-100 text-sm flex items-center gap-4 p-4 bg-primary-400 dark:bg-primary-600/60 rounded-lg bg-primary-900 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-slate-900 dark:text-white text-slate-800 dark:text-slate-100 text-sm info Why This Approach? list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 LimelightHelpers.java LimelightVision/limelightlib-wpijava main LimelightHelpers Reference implementation for LimelightHelpers. Used by the Limelight subsystem above to retrieve pose estimates and raw vision measurements. Limelight.java Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Limelight.java Limelight Code Subsystem that pulls robot pose from LimelightHelpers, validates the estimate, models measurement noise from tag distance/count, and feeds pose+timestamp+std devs to a consumer (e.g., your drivetrain pose estimator). Caches the last valid estimate and exposes getters for logging. RobotContainer.java text-slate-600 dark:text-slate-300 mb-4 src/main/java/frc/robot/RobotContainer.java grid md:grid-cols-2 gap-6 bg-green-50 dark:bg-green-900/20 p-6 rounded-lg border-l-4 border-green-500 text-lg font-semibold text-green-900 dark:text-green-300 mb-4 bg-red-50 dark:bg-red-900/20 p-6 rounded-lg border-l-4 border-red-500 text-lg font-semibold text-red-900 dark:text-red-300 mb-4 grid md:grid-cols-2 gap-4 https://docs.limelightvision.io/docs/docs-limelight/apis/complete-networktables-api Limelight NetworkTables API w-5 h-5 https://docs.wpilib.org/en/stable/docs/software/vision-processing/apriltag/apriltag-intro.html WPILib AprilTag Guide bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/vision-implementation",
    category: "Workshop 2",
    tags: [
      "vision-implementation",
      "robot",
      "subsystem",
      "ctre",
      "command",
      "workshop",
      "motor",
      "pid",
      "control",
      "java",
      "frc",
    ],
  },
  {
    id: "vision-options",
    title: "Vision Options",
    description:
      "Overview of computer vision options for FRC robots including cameras and vision processing.",
    content:
      "Why Vision Matters in FRC AprilTags provide known field positions, enabling accurate robot localization and drift correction for odometry. Detect and track notes, cones, cubes, or other game pieces for autonomous pickup and scoring. Aim and shoot at targets dynamically, adjusting for robot and target movement in real-time. Modern FRC requires vision for autonomous accuracy and teleop assistance. Top teams use multiple cameras for comprehensive field awareness. FRC Vision System Options Limelight Dedicated vision hardware with integrated processing, LEDs, and NetworkTables interface. Plug-and-play solution optimized for FRC. ‚úÖ Advantages Zero code required for basic detection Built-in LED ring for consistent lighting Hardware-accelerated processing Web interface for tuning pipelines NetworkTables integration out-of-box Proven reliability in competition ‚ö†Ô∏è Limitations Higher cost (~$400-500) Proprietary hardware and software Limited customization vs open source üéØ Best For Teams who want reliable, proven vision hardware with minimal setup. Ideal for teams prioritizing ease-of-use over cost. PhotonVision Open-source vision software that runs on coprocessors (Raspberry Pi, Orange Pi, etc.). Flexible and cost-effective alternative. Free and open source Works with any USB camera Active development and community Advanced AprilTag support Multi-tag pose estimation Lower total cost (~$100-150) Requires coprocessor setup More configuration complexity Camera and lighting selection matters Performance depends on hardware chosen Teams who want cost-effective vision with flexibility and don't mind additional setup complexity. Great for AprilTag localization. Vision System Comparison Feature Cost $400-500 $100-150 Setup Complexity Very Easy Moderate Hardware Integrated unit Coprocessor + Camera AprilTag Support Yes Custom Pipelines Web interface Web interface + Code Community Support Large, established Growing, active Best Use Case Plug-and-play reliability Cost-effective flexibility AprilTag Localization AprilTags are fiducial markers placed at known locations on the FRC field. Cameras can detect these tags and calculate the robot's absolute field position. How AprilTags Work Tags have unique IDs corresponding to field positions Camera detects tag and calculates relative pose Robot position computed from known tag location Multiple tags improve accuracy through fusion Benefits for FRC Corrects odometry drift automatically Enables accurate autonomous navigation Works regardless of starting position Provides absolute field coordinates Many top teams use multiple cameras: one facing forward for game pieces, and others positioned to always see AprilTags for continuous localization. Recommended Approach for This Workshop üì∑ Using Limelight For this workshop, we'll use Limelight for its simplicity and reliability. The focus is on integrating vision data into your robot code, not configuring vision hardware. What You'll Learn Reading vision data from NetworkTables Integrating AprilTag poses into odometry Using vision for target tracking Commanding turrets/shooters based on vision Additional Resources What's Next? Up Next: Implementing Vision You'll integrate Limelight into your swerve drivetrain for AprilTag-based pose estimation and odometry correction. Vision Options /logging-implementation Implementing Logging /vision-implementation Implementing Vision Computer Vision - See the Field Computer vision enables robots to detect game pieces, track targets, and localize position using cameras. AprilTag targets provide absolute field positioning, while object detection helps with game piece manipulation. Vision transforms robots from blind machines into field-aware systems that can adapt to dynamic conditions. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-3 gap-6 Absolute Positioning Game Piece Detection Target Tracking info üí° Vision is Essential for Competitive Play bg-slate-50 dark:bg-slate-900 rounded-lg p-8 border border-slate-200 dark:border-slate-800 flex items-start gap-4 mb-6 bg-primary-600 text-white rounded-lg px-4 py-2 font-bold text-lg flex-1 text-2xl font-bold text-slate-900 dark:text-slate-100 mb-2 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 gap-6 font-semibold text-slate-900 dark:text-slate-100 mb-3 list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 mt-6 text-sm text-slate-600 dark:text-slate-300 https://docs.limelightvision.io/docs/docs-limelight/getting-started/summary Limelight Documentation w-5 h-5 bg-green-600 text-white rounded-lg px-4 py-2 font-bold text-lg https://docs.photonvision.org/ PhotonVision Documentation overflow-x-auto w-full border-collapse border-b-2 border-slate-300 dark:border-slate-700 text-left p-4 font-semibold text-slate-900 dark:text-slate-100 border-b border-slate-200 dark:border-slate-800 p-4 font-medium text-slate-900 dark:text-slate-100 p-4 text-slate-600 dark:text-slate-300 text-xl font-bold text-primary-900 dark:text-primary-300 mb-4 text-xl font-bold text-green-900 dark:text-green-300 mb-4 tip üí° Multi-Camera Setup bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-6 text-slate-600 dark:text-slate-300 mb-6 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 font-bold text-primary-600 dark:text-primary-400 mb-3 grid md:grid-cols-2 gap-4 https://docs.limelightvision.io/ bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/vision-options",
    category: "Workshop 2",
    tags: ["vision-options", "frc", "robot", "hardware", "workshop"],
  },
  {
    id: "vision-shooting",
    title: "Vision-Based Shooting",
    description:
      "Advanced application combining vision systems with shooting mechanisms for accurate targeting.",
    content:
      "Vision-Based Shooting /swerve-calibration Odom Calibration /state-based State-Based Control",
    url: "/vision-shooting",
    category: "Workshop 2",
    tags: ["vision-shooting", "control"],
  },
];
