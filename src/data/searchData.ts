// This file is auto-generated by scripts/generate-search-data.js
// Do not edit manually - changes will be overwritten during build
// Run 'npm run generate-search' to regenerate from page content

export interface SearchItem {
  id: string;
  title: string;
  description: string;
  content: string;
  url: string;
  category: string;
  tags: string[];
}

export const searchData: SearchItem[] = [
  {
    id: "adding-commands",
    title: "Adding Commands",
    description:
      "Creating and implementing commands to control robot subsystems.",
    content:
      'Command Structure & Examples üéÆ Inline Command Methods Example return runOnce(() -> action); Create commands using factory methods like runOnce() to execute actions once when the command is triggered. addRequirements(subsystem); Commands must declare which subsystems they use to prevent conflicts and ensure proper scheduling. initialize() ‚Üí execute() ‚Üí end() Commands have a clear lifecycle: start, run continuously, then clean up when finished. moveUp(): Positive voltage for upward movement", "‚Ä¢ moveDown(): Negative voltage for downward movement", ], rightTitle: "Command Benefits", rightItems: [ "‚Ä¢ Encapsulation: Actions wrapped in reusable commands", "‚Ä¢ Safety: Automatic stop when command ends", "‚Ä¢ Flexibility: runSlow(): Low voltage (3V) for testing", "‚Ä¢ runFast(): High voltage (6V) for shooting", ], rightTitle: "Command Benefits", rightItems: [ "‚Ä¢ Commands /building-subsystems Subsystems /triggers Triggers Commands - Coordinating Robot Actions Commands are the actions that your robot performs. They use subsystems to accomplish tasks and can be triggered by user input, sensors, or automated sequences. Commands tell subsystems what action to run. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 card p-6 text-xl font-bold text-primary-600 mb-4 cursor-pointer hover:text-primary-700 dark:hover:text-primary-300 mt-4 java Subsystem Command Methods grid md:grid-cols-3 gap-6 ‚ö° Command Methods üîó Command Requirements üîÑ Command Lifecycle Workshop Implementation ‚Ä¢ Arm subsystem with basic voltage control ‚Ä¢ No user input integration ‚Ä¢ No commands to coordinate actions ‚Ä¢ Manual method calls only ‚Ä¢ Enhanced Arm subsystem methods ‚Ä¢ Commands for moveUp(), moveDown() ‚Ä¢ Ready for user input integration Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 2-Commands Arm.java New Subsystem Methods ‚Ä¢ <strong>moveUp():</strong> Positive voltage for upward movement ‚Ä¢ <strong>moveDown():</strong> Negative voltage for downward movement Command Benefits ‚Ä¢ <strong>Encapsulation:</strong> Actions wrapped in reusable commands ‚Ä¢ <strong>Safety:</strong> Automatic stop when command ends ‚Ä¢ <strong>Flexibility:</strong> Ready for trigger integration Enhanced Arm subsystem with command methods! Next, we ‚Ä¢ Flywheel subsystem with basic voltage control ‚Ä¢ Enhanced Flywheel subsystem methods ‚Ä¢ Commands for runSlow(), runFast() src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>runSlow():</strong> Low voltage (3V) for testing ‚Ä¢ <strong>runFast():</strong> High voltage (6V) for shooting Enhanced Flywheel subsystem with command methods! Next, we üìù Knowledge Check What is the primary purpose of commands in command-based programming? To configure motor hardware settings To coordinate robot actions using subsystems To read sensor data To manage network communications What does the runOnce() factory method do? Runs a command continuously until stopped Executes an action once when the command is triggered Schedules a command to run at a specific time Repeats a command exactly once per second The runOnce() factory method creates a command that executes the specified action once when triggered, then immediately finishes. Why must commands declare which subsystems they use with addRequirements()? To improve code performance To prevent conflicts and ensure proper scheduling To enable telemetry logging To configure motor parameters Commands must declare their subsystem requirements to prevent conflicts (two commands trying to control the same subsystem) and ensure the command scheduler properly manages command execution. What is the correct order of the command lifecycle? execute() ‚Üí initialize() ‚Üí end() end() ‚Üí initialize() ‚Üí execute() initialize() ‚Üí end() ‚Üí execute() Commands follow the lifecycle: initialize() (called once at start) ‚Üí execute() (called repeatedly) ‚Üí end() (called once when finished). This provides clear start, run, and cleanup phases.',
    url: "/adding-commands",
    category: "Workshop 1",
    tags: [
      "adding-commands",
      "command",
      "subsystem",
      "robot",
      "java",
      "workshop",
      "control",
      "frc",
      "motor",
      "hardware",
    ],
  },
  {
    id: "ai-assistant",
    title: "ai-assistant",
    description: "",
    content:
      'Ask questions about the FRC Programming Workshop. The AI assistant has access to all workshop content and remembers your conversation history for contextual follow-up questions. Custom API Key (Optional) Get an API key Using custom API key Start a conversation Ask me anything about FRC programming, command-based architecture, PID tuning, or any workshop topics! I remember our conversation, so feel free to ask follow-up questions. ) : ( part.type === "text" ? part.text : "" ) .join(""); return ( Thinking... Error: Send use client react-syntax-highlighter/dist/esm/styles/prism system light gemini-api-key ready submitted streaming AI Workshop Assistant max-w-4xl mx-auto mb-6 flex items-center gap-2 mb-2 true presentation w-6 h-6 text-primary-600 dark:text-primary-400 text-slate-600 dark:text-slate-300 card p-4 mb-4 flex items-start gap-3 w-5 h-5 text-primary-600 dark:text-primary-400 mt-0.5 flex-shrink-0 flex-1 text-sm font-semibold text-slate-700 dark:text-slate-300 text-xs text-slate-600 dark:text-slate-400 mb-3 https://aistudio.google.com/apikey _blank noopener noreferrer text-primary-600 dark:text-primary-400 hover:underline flex gap-2 text password Enter your Gemini API key... flex-1 px-3 py-2 text-sm rounded-lg border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-primary-500 button px-3 py-2 text-sm bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 text-slate-700 dark:text-slate-300 rounded-lg transition-colors Hide Show text-xs text-green-600 dark:text-green-400 mt-2 card p-4 mb-4 min-h-[400px] max-h-[600px] overflow-y-auto flex flex-col items-center justify-center h-full text-center py-12 w-12 h-12 text-slate-400 dark:text-slate-500 mb-4 text-xl font-semibold text-slate-700 dark:text-slate-300 mb-2 text-slate-500 dark:text-slate-400 max-w-md space-y-4 assistant user justify-end justify-start bg-primary-600 text-white bg-slate-100 dark:bg-slate-700 text-slate-900 dark:text-slate-100 break-words whitespace-pre-wrap prose prose-slate dark:prose-invert max-w-none prose-code:text-primary-600 dark:prose-code:text-primary-400 bg-slate-200 dark:bg-slate-600 px-1.5 py-0.5 rounded text-sm font-mono dark div 1rem 0 0.5rem 0.875rem text-primary-600 dark:text-primary-400 hover:underline inline-flex items-center gap-1 http w-3 h-3 text-primary-100 text-slate-500 dark:text-slate-400 flex justify-start bg-slate-100 dark:bg-slate-700 rounded-lg p-4 flex items-center gap-2 animate-spin rounded-full h-4 w-4 border-b-2 border-primary-600 mb-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg flex items-center gap-2 text-red-700 dark:text-red-400 w-5 h-5 font-semibold Ask about subsystems, commands, PID tuning... flex-1 px-4 py-3 rounded-lg border border-slate-300 dark:border-slate-600 bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 focus:outline-none focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed submit px-6 py-3 bg-primary-600 hover:bg-primary-700 text-white rounded-lg font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center gap-2 w-4 h-4',
    url: "/ai-assistant",
    category: "General",
    tags: ["ai-assistant", "frc", "workshop", "command", "pid"],
  },
  {
    id: "building-subsystems",
    title: "Building Subsystems",
    description:
      "Creating subsystems for robot mechanisms and understanding subsystem structure.",
    content:
      'Subsystem Structure & Code Examples TalonFX motor = new TalonFX(1); Motors, sensors, and other hardware objects are declared as private fields at the top of the class. motor.getConfigurator() &nbsp;&nbsp;&nbsp;&nbsp;.apply(config); Motor configurations, current limits, and mode settings go in the constructor to run once at startup. SmartDashboard.putNumber( &nbsp;&nbsp;&nbsp;&nbsp;"Value", sensor.get()); Runs every 20ms (50Hz). Use for telemetry, monitoring, and updating dashboard values - not for control! TalonFX Motor: Main drive motor with integrated controller", "‚Ä¢ CANcoder: Absolute position feedback sensor", "‚Ä¢ Remote Sensor: CANcoder connected as remote feedback", ], rightTitle: "Key Methods", rightItems: [ "‚Ä¢ setVoltage(): Direct voltage control for basic movement", "‚Ä¢ stop(): Safe motor stop with neutral output", "‚Ä¢ periodic(): Leader Motor: TalonFX controlling the flywheel mechanism", "‚Ä¢ Follower Motor: Second TalonFX following the leader", "‚Ä¢ CANivore Bus: High-speed CAN bus for motor communication", ], rightTitle: "Key Methods", rightItems: [ "‚Ä¢ Direct voltage control for flywheel speed", "‚Ä¢ not have a physical follower motor. However, the following code examples include a follower motor setup to demonstrate best practices for multi-motor subsystems. If implementing on actual hardware, you would either remove the follower motor code or add a second physical motor to your flywheel mechanism. Subsystems /command-framework Command-Based Framework /adding-commands Commands Subsystems - Understanding the Foundation Subsystems form the building blocks of command-based programming. Each subsystem models a physical part of the robot and provides safe, organized methods to control it. Subsystems can vary in scope‚Äîfrom a single motor to an entire mechanism‚Äîdepending on how you choose to structure your code. One subsystem per mechanism. Each subsystem manages its own hardware and state. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 üì¶ Basic Subsystem Example java ExampleSubsystem.java Motor Position Motor Velocity Motor Current grid md:grid-cols-3 gap-6 üîß Hardware Instantiation ‚öôÔ∏è Configuration Location üîÑ Periodic Method Workshop Implementation ‚Ä¢ Basic WPILib project structure ‚Ä¢ No hardware integration ‚Ä¢ No subsystem implementation ‚Ä¢ Complete Arm subsystem class ‚Ä¢ TalonFX motor (ID: 31) configured ‚Ä¢ CANcoder sensor (ID: 22) integrated ‚Ä¢ Basic voltage control methods Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 1-Subsystem Arm.java Hardware Setup ‚Ä¢ <strong>TalonFX Motor:</strong> Main drive motor with integrated controller ‚Ä¢ <strong>CANcoder:</strong> Absolute position feedback sensor ‚Ä¢ <strong>Remote Sensor:</strong> CANcoder connected as remote feedback Key Methods ‚Ä¢ <strong>setVoltage():</strong> Direct voltage control for basic movement ‚Ä¢ <strong>stop():</strong> Safe motor stop with neutral output ‚Ä¢ <strong>periodic():</strong> Understand that periodic runs every robot loop This subsystem is ready for command integration! Next, we ‚Ä¢ Complete Flywheel subsystem class ‚Ä¢ Dual TalonFX motors (IDs: 21, 22) configured ‚Ä¢ Leader/follower motor setup src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>Leader Motor:</strong> TalonFX controlling the flywheel mechanism ‚Ä¢ <strong>Follower Motor:</strong> Second TalonFX following the leader ‚Ä¢ <strong>CANivore Bus:</strong> High-speed CAN bus for motor communication ‚Ä¢ <strong>setVoltage():</strong> Direct voltage control for flywheel speed This flywheel subsystem is ready for command integration! Next, we warning w-6 h-6 none currentColor 0 0 24 24 round M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z Caution: Physical Hardware vs Code Example mb-3 Note mt-3 üìù Knowledge Check What is the primary purpose of a subsystem in command-based programming? To store autonomous routines To model a physical part of the robot and provide safe, organized methods to control it To handle all user input from controllers To manage network communications Subsystems model physical parts of the robot (like arms or flywheels) and provide safe, organized methods to control them. Each subsystem manages its own hardware and state. Where should motors and sensors be instantiated in a subsystem? In the periodic() method In command methods As private fields at the top of the class In RobotContainer Motors, sensors, and other hardware objects should be declared as private fields at the top of the subsystem class. This makes them accessible throughout the subsystem while keeping them encapsulated. What is the correct place to configure motor settings like neutral mode and current limits? In the periodic() method, so they update constantly In the subsystem constructor, to run once at startup In each command that uses the motor Motor configurations should go in the constructor to run once at robot startup. This includes settings like neutral mode, current limits, and PID gains. How often does the periodic() method run in a subsystem? Once per second Only when a command is running Every 20ms (50 times per second) Only when manually called The periodic() method runs every 20ms (50Hz) automatically. It In the flywheel subsystem example, what is the purpose of setting up a follower motor? To provide redundancy in case the leader motor fails To make the second motor automatically mirror the leader motor To double the available power output To monitor the leader motor A follower motor is configured to automatically mirror the leader motor',
    url: "/building-subsystems",
    category: "Workshop 1",
    tags: [
      "building-subsystems",
      "subsystem",
      "motor",
      "hardware",
      "control",
      "command",
      "robot",
      "java",
      "workshop",
      "frc",
      "pid",
    ],
  },
  {
    id: "command-framework",
    title: "Command-Based Framework",
    description:
      "Understanding the command-based programming paradigm and its benefits for robot code organization.",
    content:
      'Use BooleanSuppliers (True or False) Link inputs to commands (e.g., press button to drive forward, or use sensor to run Command automatically). All buttons/triggers on a game controller are considered "Triggers". Hardware components and control logic (e.g., Drivetrain, Arm, or Flywheel). Motors and sensors are instantiated. Methods to pull data from sensors within the subsystem are defined. Use Runnables (void functions) Encapsulate robot actions (e.g., DriveForwardCommand, ShootBallCommand). Progressive Implementation Path Follow our step-by-step implementation guide to build a complete command-based robot system. Each pull request builds on the previous one, teaching core concepts progressively. üöÄ Implementation Sequence Building Subsystems Hardware instantiation, motor configuration, and basic control methods Adding Commands Command structure and creation methods Triggers User input binding and advanced command patterns PID Control Precise position control with feedback and tuning Motion Magic Smooth profiled motion with acceleration control Useful Functions Safety features, diagnostics, and utility functions üìö Official WPILib Command-Based Documentation For comprehensive Command-Based Framework reference, advanced patterns, and complete API documentation: Command-Based Framework /project-setup Project Setup /building-subsystems Command-Based Framework - Core Programming Concepts The Command-Based Framework organizes robot code into three key components: Triggers (inputs), Subsystems (hardware), and Commands (actions). This structure provides clean separation of concerns and reliable robot behavior. Command-based programming is the format in which you will write your code. grid md:grid-cols-3 gap-6 Subsystems Commands flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 grid md:grid-cols-1 gap-6 text-xl font-bold text-[var(--foreground)] mb-4 space-y-4 flex items-center gap-4 p-4 bg-primary-50 dark:bg-primary-950/20 rounded-lg bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-700 dark:text-primary-300 text-primary-600 dark:text-primary-400 text-sm flex items-center gap-4 p-4 bg-primary-100 dark:bg-primary-900/30 rounded-lg bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-800 dark:text-primary-200 text-primary-700 dark:text-primary-300 text-sm flex items-center gap-4 p-4 bg-primary-200 dark:bg-primary-800/40 rounded-lg bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-900 dark:text-primary-100 text-primary-800 dark:text-primary-200 text-sm flex items-center gap-4 p-4 bg-primary-300 dark:bg-primary-700/50 rounded-lg bg-primary-800 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-950 dark:text-white text-primary-900 dark:text-primary-100 text-sm flex items-center gap-4 p-4 bg-primary-400 dark:bg-primary-600/60 rounded-lg bg-primary-900 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-slate-900 dark:text-white text-slate-800 dark:text-slate-100 text-sm flex items-center gap-4 p-4 bg-primary-500 dark:bg-primary-500/70 rounded-lg bg-slate-900 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-[var(--foreground)] mb-4 https://docs.wpilib.org/en/stable/docs/software/commandbased/index.html WPILib Command-Based Programming Guide w-5 h-5 üìù Knowledge Check What are the three key components of the Command-Based Framework? Motors, Sensors, and Controllers Triggers, Subsystems, and Commands Autonomous, Teleop, and Test modes Hardware, Software, and Network The Command-Based Framework consists of three key components: Triggers (inputs), Subsystems (hardware), and Commands (actions). This structure provides clean separation of concerns. What do Triggers represent in the Command-Based Framework? Physical hardware components like motors Actions that the robot performs Inputs that link to commands using BooleanSuppliers (True or False) Configuration files for the robot Triggers represent inputs that link to commands. They use BooleanSuppliers (True/False conditions) such as button presses, sensor readings, or custom logic to determine when commands should run. What is the primary role of Subsystems in command-based programming? To execute autonomous routines To represent hardware components and provide control logic To manage network communications To handle user input from controllers Subsystems represent hardware components (like Drivetrain, Arm, or Flywheel) and contain the control logic for those components. Motors and sensors are instantiated within subsystems. What do Commands encapsulate in the Command-Based Framework? Hardware configuration settings Sensor calibration data Robot actions using Runnables (void functions) Network protocol definitions Commands encapsulate robot actions (like DriveForwardCommand or ShootBallCommand) using Runnables (void functions). They coordinate subsystems to accomplish specific tasks. What is the recommended implementation sequence for building a command-based robot system? Commands ‚Üí Triggers ‚Üí Subsystems ‚Üí PID Control Subsystems ‚Üí Commands ‚Üí Triggers ‚Üí PID Control ‚Üí Motion Magic Triggers ‚Üí Commands ‚Üí Subsystems ‚Üí Motion Magic PID Control ‚Üí Subsystems ‚Üí Commands ‚Üí Triggers The recommended sequence is: 1) Building Subsystems (hardware), 2) Adding Commands (actions), 3) Triggers (user input), 4) PID Control (precise control), 5) Motion Magic (profiled motion), 6) Useful Functions (utilities). Each step builds on the previous one.',
    url: "/command-framework",
    category: "Workshop 1",
    tags: [
      "command-framework",
      "command",
      "hardware",
      "control",
      "subsystem",
      "robot",
      "motor",
      "pid",
    ],
  },
  {
    id: "hardware",
    title: "Hardware Setup",
    description:
      "Overview of CTRE hardware components including Kraken X44 motors, CANcoders, and CANivore setup.",
    content:
      'Hardware Components Kraken X44 Brushless Motor Powered by Talon FX‚Ñ¢ Compact brushless motor with integrated Talon FX‚Ñ¢ controller. Delivers 823W peak power. Key Features: 4.05Nm stall torque, 85% max efficiency, 125.5 RPS max speed, SplineXS shaft, FOC commutation, 1kHz PID control, compact 44mm design. WCP ThroughBore Encoder ‚Äì CAN Bus Position Sensor Through bore rotary sensor using innovative off-axis magnet technology. Eliminates mechanical coupling for precise shaft position measurement. 1/2" hex shaft compatible, through bore design, absolute/relative position, CAN bus connectivity, versatile mounting options. CANivore‚Ñ¢ ‚Äì CAN FD Bus Expansion USB-to-CAN FD interface that adds new CAN FD network to PC or roboRIO. Enables precise control of CTRE devices with Phoenix Pro and hardware-attached simulation. CAN FD technology (2X-8X better bus utilization), wireless configuration, ESP32 integration, multi-color status LEDs, USB Type-C support. Why We Choose CTRE Hardware üéØ CTRE\'s Unique Advantages Full PID Control Complete PID implementation with kP, kI, kD, and advanced filtering options that other vendors don\'t provide. Feedforward (FF) Built-in feedforward control for gravity compensation and velocity control that competitors lack. Motion Profiling Advanced Motion Magic and motion profiling capabilities for smooth, controlled movements. Rotations Units Motor positions measured in intuitive rotations instead of confusing encoder ticks or radians. üîß Phoenix Software Resources ‚Üí CANivore Introduction ‚Üí Phoenix 6 Documentation ‚Üí Phoenix 6 API Reference ‚Üí Phoenix Tuner X Documentation Connecting to Your Device Plug the computer into CANivore Make sure the "CANivore USB" is checked Change "Team # or IP" to "localhost" Your CANivore should now appear in Phoenix Tuner For this workshop, please name your CANivore: "canivore" Updating Your CTRE Products Using Phoenix Tuner Open Phoenix Tuner and connect to your robot If you have issues connecting to your robot, view this guide Batch update all products of the same model Select one of the devices and then click the batch update icons Verify Updates The device cards will be green if the firmware is the latest Motor Update Process & Status Colors üì± How to Update Motors Use Phoenix Tuner to update your motor firmware. Select devices and use the batch update feature to ensure all motors are running the latest firmware version. The color of the device cards is helpful as a visual indicator of device state. The meaning of the card color is also shown as text underneath the device title. Color Description Green Device has latest firmware. Purple Device has an unexpected/beta firmware version. Yellow A new firmware version is available. Red Device has a duplicate ID. Blue Failed to retrieve list of available firmware. Always update all motors to the same firmware version for consistency and use batch update to save time when updating multiple devices. Having Issues? If you are having issues connecting to your CANivore or other devices, make sure to update your CANivore firmware. Let\'s Run Some Motors! Testing Motor Movement Quick Test Steps: Open up your motor in Phoenix Tuner Click Config Click the three dots Factory Default Set the drop-down to Voltage Out DISABLED to enable Apply voltage to test the motor ‚ö° Safety First Always start with low voltage values when testing motors. Make sure your mechanism can move freely and won\'t cause damage. Hardware Setup /mechanism-cad Mechanism CAD /project-setup Project Setup Hardware Setup - Building the Foundation Overview of the motors, sensors, and controllers you Solid hardware configuration enables precise and reliable robot control. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-1 lg:grid-cols-3 gap-8 /images/hardware/Kraken44x.png Kraken Motor mb-4 text-xl font-bold text-slate-900 dark:text-slate-100 mb-3 https://store.ctr-electronics.com/products/kraken-x44 _blank noopener noreferrer text-primary-600 hover:text-primary-800 underline dark:text-primary-400 dark:hover:text-primary-300 text-slate-600 dark:text-slate-300 mb-3 bg-primary-100 dark:bg-primary-900/20 p-3 rounded-lg text-sm text-primary-800 dark:text-primary-300 /images/hardware/Encoder.png CANcoder https://store.ctr-electronics.com/products/wcp-throughbore-encoder /images/hardware/CANivore.png CANivore https://store.ctr-electronics.com/canivore/ bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-4 grid md:grid-cols-4 gap-4 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 font-bold text-primary-600 dark:text-primary-400 mb-2 text-sm text-slate-600 dark:text-slate-300 font-bold text-[var(--foreground)] mb-2 font-bold text-green-600 dark:text-green-400 mb-2 font-bold text-orange-600 dark:text-orange-400 mb-2 mt-8 bg-slate-50 dark:bg-slate-900 rounded-lg p-6 border border-slate-200 dark:border-slate-800 grid md:grid-cols-2 gap-4 https://v6.docs.ctr-electronics.com/en/stable/docs/canivore/canivore-intro.html block text-primary-600 underline hover:no-underline hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300 font-medium https://v6.docs.ctr-electronics.com/ https://v6.docs.ctr-electronics.com/en/stable/docs/api-reference/ https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/ warning ‚ö†Ô∏è Important Setup Steps list-decimal list-inside space-y-2 p-8 space-y-4 flex items-start space-x-3 bg-green-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold font-medium text-slate-600 dark:text-slate-300 text-sm https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/connecting.html#connecting-tuner text-primary-600 underline hover:no-underline dark:text-primary-400 ml-1 mx-auto flex flex-col gap-4 text-xl font-semibold text-slate-900 dark:text-slate-100 https://www.youtube.com/embed/aktcCtcrEyY Motor Update Process accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full h-full aspect-video rounded-lg info üé® Card Colors mb-3 bg-slate-50 dark:bg-slate-900 rounded-lg p-4 overflow-x-auto w-full text-left border-b border-slate-200 dark:border-slate-700 py-2 px-3 font-semibold text-slate-900 dark:text-slate-100 w-32 py-2 px-3 font-semibold text-slate-900 dark:text-slate-100 text-sm border-b border-slate-100 dark:border-slate-800 py-3 px-3 align-top flex items-center whitespace-nowrap inline-block w-4 h-4 bg-green-500 rounded-full mr-2 flex-shrink-0 text-green-700 dark:text-green-400 py-3 px-3 text-slate-700 dark:text-slate-300 align-top inline-block w-4 h-4 bg-purple-500 rounded-full mr-2 flex-shrink-0 text-purple-700 dark:text-purple-400 inline-block w-4 h-4 bg-yellow-500 rounded-full mr-2 flex-shrink-0 text-yellow-700 dark:text-yellow-400 inline-block w-4 h-4 bg-red-500 rounded-full mr-2 flex-shrink-0 text-red-700 dark:text-red-400 inline-block w-4 h-4 bg-blue-500 rounded-full mr-2 flex-shrink-0 text-blue-700 dark:text-primary-400 tip üí° Tip mt-4 text-slate-600 dark:text-slate-300 https://www.youtube.com/embed/TkScJADvD-Y CANivore Setup bg-primary-100 dark:bg-primary-900/20 border border-blue-200 dark:border-blue-900 rounded-lg p-6 text-lg font-semibold text-primary-900 dark:text-primary-300 mb-4 grid md:grid-cols-2 gap-6 mb-6 font-semibold text-[var(--foreground)] mb-3 list-decimal list-inside space-y-2 text-[var(--foreground)] bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-[var(--border)] font-semibold text-slate-900 dark:text-slate-100 mb-2 https://www.youtube.com/embed/cDWF3bj1Juk Motor Test Hardware Setup Quiz What makes CTRE hardware unique compared to other motor controllers? Full PID control, feedforward, motion profiling, and rotations units It only works with specific robot designs It requires less power than other controllers CTRE hardware offers complete PID implementation with kP, kI, kD, built-in feedforward control for gravity and velocity compensation, advanced Motion Magic profiling, and uses intuitive rotation units instead of encoder ticks or radians. What is the purpose of the CANivore in your robot It provides power to all motors It stores robot code and configuration files CANivore is a USB-to-CAN FD interface that adds a new CAN FD network to your PC or roboRIO, enabling precise control of CTRE devices with better bus utilization (2X-8X) and supporting hardware-attached simulation. What does a GREEN device card in Phoenix Tuner indicate? The device needs a firmware update The device has a duplicate ID The device has the latest firmware Failed to retrieve firmware information A green device card indicates that the device has the latest firmware installed and is ready for use. What are the three main hardware components used in this workshop? roboRIO, battery, and radio Kraken X44 motor, WCP ThroughBore Encoder, and CANivore Pneumatic hub, compressor, and solenoid Power distribution hub, motor, and joystick The workshop uses Kraken X44 brushless motors (with integrated Talon FX controller), WCP ThroughBore Encoders (for absolute position sensing), and CANivore (for CAN FD communication). When connecting to your CANivore for the first time, what should you set the field to? Your team number 192.168.1.1 localhost 10.0.0.1 When connecting to your CANivore via USB, you should set the field to and ensure is checked in Phoenix Tuner X.',
    url: "/hardware",
    category: "Workshop 1",
    tags: ["hardware", "motor", "pid", "control", "ctre", "workshop", "robot"],
  },
  {
    id: "introduction",
    title: "Introduction - Gray Matter Coding Workshop",
    description:
      "Overview of the workshop goals, target audience, and what you'll learn about FRC programming best practices.",
    content:
      "Quick Note All underlined text and images of code or products will have built-in links to resources Before You Begin Review prerequisites Why Are We Here? Learn FRC's Best Programming Practices Master industry-standard coding patterns, command-based architecture, and proven development workflows that successful FRC teams use. Build Competition-Winning Robots Develop reliable, maintainable code that performs under pressure and helps your team succeed at districts, regionals and FIRST Championship. Target Audience & Goals Who This Workshop Is For This workshop is designed for FRC Teams using Java and CTRE Hardware. What You'll Learn ‚Ä¢ Code architecture and best practices ‚Ä¢ Subsystems structure and organization ‚Ä¢ Command-based programming framework ‚Ä¢ PID tuning techniques ‚Ä¢ Libraries and framework usage ‚Ä¢ Hardware integration with CTRE devices ‚Ä¢ Motion profiling and control ‚Ä¢ Real-world competition implementation Our Mission This site was created by Team 5712, Hemlocks Gray Matter, with support from its friends as a resource to cover introductory to advanced topics while providing a clear learning and implementation plan. We are excited for you to learn code architecture, command-based programming, and more! Choose Your Workshop Workshop #1 Fundamentals of FRC programming with command-based framework, subsystems, and PID control. Hardware Setup Project Setup Mechanism Setup Command-Based Framework Building Subsystems Adding Commands Triggers Running Program PID Control Motion Magic State-Based Control Start Workshop #1 Workshop #2 Advanced topics including swerve drive, vision systems, path planning, and data logging. Swerve Prerequisites Swerve Drive Project PathPlanner Logging Options Logging Implementation Vision Options Vision Implementation Odometry Calibration Vision-Based Shooting Start Workshop #2 Gray Matter Coding Workshop Home /prerequisites Prerequisites bg-primary-50 dark:bg-primary-950/30 border-l-4 border-primary-400 dark:border-primary-900 p-6 text-lg font-medium text-primary-900 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300 bg-amber-50 dark:bg-amber-950/30 border-l-4 border-amber-400 dark:border-amber-900 p-6 text-lg font-medium text-amber-900 dark:text-amber-300 mb-2 text-amber-800 dark:text-amber-300 underline font-semibold hover:text-amber-900 dark:hover:text-amber-200 transition-colors flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 space-y-6 border-l-4 border-orange-200 dark:border-orange-900 pl-4 text-lg font-semibold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 mt-2 border-l-4 border-green-200 dark:border-green-900 pl-4 border-l-4 border-purple-200 dark:border-purple-900 pl-4 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-3 text-lg text-slate-600 dark:text-slate-300 mb-4 border-l-4 border-blue-200 dark:border-blue-900 pl-4 grid md:grid-cols-2 gap-4 space-y-2 text-slate-600 dark:text-slate-300 border-l-4 border-amber-200 dark:border-amber-900 pl-4 text-lg text-slate-600 dark:text-slate-300 grid grid-cols-1 lg:grid-cols-2 gap-6 lg:gap-8 bg-slate-50 dark:bg-slate-900 rounded-lg p-6 sm:p-8 shadow-lg border border-slate-200 dark:border-slate-800 hover:shadow-xl transition-shadow flex items-center mb-4 w-12 h-12 bg-primary-600 rounded-lg flex items-center justify-center text-white font-bold text-xl mr-4 text-2xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 mb-6 space-y-3 mb-6 /hardware block p-3 bg-slate-100 dark:bg-slate-800 rounded-lg hover:bg-primary-100 dark:hover:bg-primary-950/30 transition-colors group flex items-center justify-between font-medium text-slate-700 dark:text-slate-300 group-hover:text-primary-700 dark:group-hover:text-primary-300 text-slate-400 dark:text-slate-500 group-hover:text-primary-500 dark:group-hover:text-primary-300 /project-setup /mechanism-setup /command-framework /building-subsystems /adding-commands /triggers /running-program /pid-control /motion-magic /state-based w-full bg-primary-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-primary-700 transition-colors text-center block /swerve-prerequisites /swerve-drive-project /pathplanner /logging-options /logging-implementation /vision-options /vision-implementation /swerve-calibration /vision-shooting",
    url: "/introduction",
    category: "Getting Started",
    tags: [
      "introduction",
      "frc",
      "command",
      "workshop",
      "java",
      "ctre",
      "hardware",
      "pid",
      "control",
    ],
  },
  {
    id: "logging-implementation",
    title: "Implementing Logging",
    description:
      "Setting up and implementing comprehensive logging systems for robot data collection.",
    content:
      "Using WPILib Epilogue WPILib 2025+ includes Epilogue, an annotation-based logging framework that automatically generates logging code at compile time. Instead of manually publishing data to NetworkTables, you simply annotate your classes with @Logged. Zero boilerplate: No SmartDashboard.put() calls in periodic() Compile-time generation: Efficient code with no runtime overhead Automatic discovery: Logs all public fields/getters unless marked @NotLogged Built into WPILib 2025: No extra dependencies required DataLogManager Examples To log data from your subsystems, publish it to NetworkTables using SmartDashboard or NetworkTableInstance. DataLogManager will automatically capture it. Don't overdo it: Logging too much data can impact loop timing Use appropriate keys: Organize data with hierarchical keys (e.g., \"Subsystem/Parameter\") Avoid String spam: Strings are expensive to log at high frequency Consider sampling rate: Not all data needs 50Hz logging Workshop Code Implementation For this workshop we will use DataLogManager and Epilogue, as they work perfectly together and are built into WPILib. Robot.java - Adding Logging RobotContainer.java includes logging setup for subsystems and commands. This helps track which commands are running and monitor subsystem state. Subsystems use Epilogue's @Logged annotation to automatically log data. This example shows the CommandSwerveDrivetrain with Epilogue logging enabled. AdvantageScope AdvantageScope is a powerful log visualization tool that can both read .wpilog files for post-match analysis and connect to your robot in real-time for live data monitoring. üì° Real-Time Data Viewing AdvantageScope can connect to your robot while it's running to view live data through NetworkTables. Open AdvantageScope on your driver station Select \"Connect to Robot\" from the menu Enter your team number or robot IP address (e.g., roborio-TEAM-frc.local) AdvantageScope connects via NetworkTables Add graphs and visualizations to monitor data in real-time Perfect for tuning PID controllers and debugging sensors üì• Post-Match Log Analysis Download and analyze .wpilog files after matches for detailed performance review. Connect to roboRIO via USB or WiFi Open web browser to roborio-TEAM-frc.local Navigate to the /logs/ directory Download .wpilog files from recent matches Open the log file in AdvantageScope Add line graphs for numeric data Use 3D field view for odometry visualization Scrub timeline to analyze specific moments When connecting to your robot in real-time, AdvantageScope uses NetworkTables to subscribe to the data being published by your robot code. This means: You can see live sensor values and motor outputs as your robot runs Changes to PID gains or other parameters can be tested immediately No need to wait for match completion to download and analyze logs Real-time data is not automatically saved unless DataLogManager is enabled Overlay multiple signals: Compare target vs actual values on same graph Video sync: Sync log data with match video for context Save layouts: Create reusable dashboard layouts for quick analysis Logging Best Practices ‚úÖ Do Log sensor inputs and motor outputs Use hierarchical key naming (Subsystem/Parameter) Log target setpoints alongside actual values Include timestamps for event logging Download logs after every match Review logs between matches to catch issues ‚ùå Don't Log high-frequency strings (use numbers/booleans) Publish the same data multiple times Ignore loop overrun warnings from excessive logging Additional Resources What's Next? Up Next: Vision Options With logging configured, you're ready to add computer vision for AprilTag localization and field-aware control. Implementing Logging /logging-options Logging Options /vision-options Vision Options Setting Up Data Logging Implementing logging in your robot code is straightforward with WPILib A few lines of code unlock comprehensive data logging for debugging and analysis. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 java Subsystem with @Logged Annotation tip üí° Epilogue Benefits list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 https://docs.wpilib.org/en/stable/docs/software/telemetry/robot-telemetry-with-annotations.html WPILib Epilogue Documentation üìä Subsystem Telemetry Example Subsystem with Telemetry canivore Arm/Position Arm/Velocity Arm/Current Arm/Voltage Arm/Temperature Arm/TargetPosition Arm/Error üó∫Ô∏è Logging Robot Pose Swerve Drive Odometry Logging Odometry/X Odometry/Y Odometry/Heading Odometry/Pose Swerve/Module /Angle /Speed warning ‚ö†Ô∏è Performance Considerations text-2xl font-semibold text-slate-900 dark:text-slate-100 Hemlock5712/Workshop-Code 2-Logging src/main/java/frc/robot/Robot.java Robot.java RobotContainer.java text-slate-600 dark:text-slate-300 mb-4 src/main/java/frc/robot/RobotContainer.java üîß Subsystem Logging Example src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java CommandSwerveDrivetrain.java grid md:grid-cols-2 gap-6 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-4 text-sm text-slate-600 dark:text-slate-300 mb-3 list-decimal list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 info üí° NetworkTables Connection mb-3 üí° AdvantageScope Pro Tips https://github.com/Mechanical-Advantage/AdvantageScope/blob/main/docs/INDEX.md AdvantageScope Documentation w-5 h-5 bg-green-50 dark:bg-green-900/20 p-6 rounded-lg border-l-4 border-green-500 text-lg font-semibold text-green-900 dark:text-green-300 mb-4 bg-red-50 dark:bg-red-900/20 p-6 rounded-lg border-l-4 border-red-500 text-lg font-semibold text-red-900 dark:text-red-300 mb-4 grid md:grid-cols-2 gap-4 https://docs.wpilib.org/en/stable/docs/software/telemetry/datalog.html WPILib DataLogManager Documentation https://github.com/Mechanical-Advantage/AdvantageScope AdvantageScope GitHub https://docs.wpilib.org/en/stable/docs/software/dashboards/smartdashboard/index.html SmartDashboard Documentation https://docs.wpilib.org/en/stable/docs/software/networktables/index.html NetworkTables Documentation üìù Knowledge Check How does Epilogue It logs data at runtime by checking annotations It automatically generates logging code at compile time with no runtime overhead It sends data directly to the driver station It replaces the need for NetworkTables Epilogue uses annotation processing to automatically generate efficient logging code at compile time. This means zero boilerplate in your code and no runtime performance overhead from reflection or annotation processing. What is the primary benefit of hierarchical key naming in logging (e.g., It makes the robot drive faster It organizes data logically for easier analysis and debugging It reduces file size It prevents NetworkTables from crashing Hierarchical key naming (like ) organizes telemetry logically, making it much easier to find and analyze specific data in AdvantageScope or other log viewers. What does AdvantageScope allow you to do with .wpilog files? Compile robot code Visualize logged data, create graphs, view 3D field positions, and scrub through match timeline Control the robot remotely Generate PathPlanner trajectories AdvantageScope is a powerful log visualization tool that lets you graph numeric data, view robot pose on a 3D field, scrub through the match timeline, and analyze performance - essential for post-match debugging and tuning. When connecting AdvantageScope to your robot in real-time, what protocol does it use? HTTP FTP NetworkTables SSH AdvantageScope connects to your robot via NetworkTables to view live data in real-time. This allows you to monitor sensor values and tune parameters during testing without waiting for match completion. What is a best practice when logging target setpoints? Never log target setpoints Log target setpoints alongside actual values for comparison Only log setpoints in autonomous mode Log setpoints to a separate file Logging target setpoints alongside actual values (e.g., target position vs actual position) is essential for analyzing PID performance, identifying tracking errors, and tuning control loops. bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/logging-implementation",
    category: "Workshop 2",
    tags: [
      "logging-implementation",
      "subsystem",
      "workshop",
      "robot",
      "java",
      "frc",
      "pid",
      "motor",
      "control",
    ],
  },
  {
    id: "logging-options",
    title: "Logging Options",
    description:
      "Data logging options for robot debugging, analysis, and performance monitoring.",
    content:
      "Why Logging is Critical in FRC üéØ The Logging Challenge During a match, your robot operates for only 2-3 minutes. When something goes wrong, you need to quickly understand what happened and fix it before the next match. Without logging, you're debugging blind. ‚ùå Without Logging Guess what went wrong based on driver observation Attempt to reproduce issues in the pits Waste time debugging problems that already occurred Miss subtle performance issues and edge cases Struggle to tune PID and feedforward values ‚úÖ With Comprehensive Logging Replay exact robot state from any match Analyze sensor data, motor outputs, and commands Identify root causes of failures quickly Optimize performance with data-driven decisions Tune PID values using real match data See exactly what your robot was doing when something went wrong. No more guessing or trying to reproduce issues. Analyze PID response curves, feedforward effectiveness, and mechanism performance with real match data. Track performance metrics across matches to identify trends and opportunities for improvement. Top FRC teams invest heavily in data logging infrastructure. Being able to quickly diagnose and fix issues between matches can mean the difference between winning and losing in elimination rounds. Modern logging frameworks make it easier than ever to capture comprehensive data without impacting robot performance. What Should You Log? Effective logging captures all relevant robot state while managing data volume and performance impact: üéÆ Inputs Joystick values and button presses Sensor readings (encoders, gyros, limit switches) Vision detection results NetworkTables values Game-specific data (alliance, match number) ü§ñ Robot State Motor outputs (voltage, current, duty cycle) Mechanism positions and velocities Robot pose (X, Y, heading) Subsystem states and modes Active commands ‚öôÔ∏è Control Signals Target setpoints and actual values PID error and output Feedforward calculations Path following targets Control loop timing While comprehensive logging is valuable, excessive logging can impact robot performance: Network bandwidth: Don't spam NetworkTables with high-frequency data CPU overhead: Logging shouldn't slow down control loops Storage space: Log files can grow large with high-frequency data Best practice: Use efficient binary logging formats and appropriate sample rates FRC Logging Framework Options Several logging frameworks are available for FRC teams. Each has different features, complexity, and use cases: DataLogManager (WPILib Built-in) Official WPILib data logging system that captures all NetworkTables data to binary .wpilog files. ‚úÖ Advantages Built into WPILib - no additional dependencies Automatically logs all NetworkTables data Efficient binary format (.wpilog) for compact storage Integrated with AdvantageScope for visualization Simple setup with one line of code Low performance overhead ‚ö†Ô∏è Limitations Only logs data published to NetworkTables No built-in replay/simulation capabilities Requires manual data publication from code Less structured than framework-based approaches üéØ Best For Teams who want simple, effective logging without additional framework complexity. Ideal for most FRC teams. AdvantageKit Comprehensive logging and replay framework developed by Team 6328 (Mechanical Advantage). Industry-leading solution for advanced teams. Deterministic replay: Re-run robot code with logged data Hardware abstraction: IO layer separation for testability Comprehensive capture: All inputs/outputs logged automatically Time-travel debugging: Step through logged matches Simulation support: Test code without hardware Integrates with AdvantageScope for visualization Significant code restructuring required Steeper learning curve for implementation Requires understanding of IO layer pattern More complex setup and maintenance Best adopted at start of season, not mid-season Advanced teams who want deterministic replay, time-travel debugging, and comprehensive testing capabilities. Requires significant investment in code architecture. Hoot Logging Lightweight logging framework specifically designed for CTRE Phoenix 6 and modern FRC hardware. Optimized for Phoenix 6 signals and CTRE hardware Automatic capture of motor controller telemetry Low overhead with efficient signal logging Simple API for custom logging Outputs to .wpilog format Works well with CANivore high-frequency data Focused primarily on CTRE ecosystem Less comprehensive than AdvantageKit Smaller community and documentation Teams using CTRE Phoenix 6 hardware who want optimized logging for motor controllers and CANivore devices. WPILib Epilogue (Java Only) Annotation-based logging framework built into WPILib 2025+. Automatically generates logging code at compile time using the @Logged annotation. Zero boilerplate: Add @Logged annotation, get automatic logging Generates efficient logging code at compile time (no runtime overhead) Logs to NetworkTables and DataLog automatically Integrates seamlessly with AdvantageScope Configurable timing (defaults to 50Hz offset from robot loop) Performance metrics logged to NetworkTables Java only (not available for C++ or Python) Requires WPILib 2025 or later Only available for teams using annotation processing (Gradle default) Less control than manual logging approaches New in 2025 - still maturing Java teams using WPILib 2025+ who want comprehensive logging with minimal code. Perfect for teams who want the simplicity of DataLogManager with better structure and less manual code. Logging Framework Comparison Feature DataLogManager Epilogue Setup Complexity Very Easy - One line Very Easy - Annotations Complex - Major restructure Easy - Simple integration Learning Curve Minimal Steep Moderate Performance Impact Very Low Very Low (compile-time) Low (when properly configured) Data Capture NetworkTables only Annotated classes Comprehensive (all I/O) Focused on CTRE devices Replay Capability No (visualization only) Yes (deterministic) Yes (limited) Visualization AdvantageScope AdvantageScope or Tuner X Community Support WPILib official Strong (Team 6328) Growing Best Use Case Most teams, simple logging Java teams, minimal boilerplate Advanced teams, comprehensive testing CTRE-focused teams Recommended Approach for This Workshop üìä Using DataLogManager + Epilogue For this workshop, we'll use a combination of WPILib's DataLogManager and Epilogue for structured annotation-based logging. This provides: Why DataLogManager? Simple setup with minimal code changes Automatic capture of NetworkTables data Official WPILib support and maintenance Works with AdvantageScope for visualization Why Add Epilogue? Zero boilerplate with @Logged annotations Automatic structured logging of subsystems Compile-time code generation (no runtime overhead) Built into WPILib 2025 - no extra dependencies As your team's sophistication grows, consider migrating to AdvantageKit for deterministic replay and comprehensive testing. However, start simple with DataLogManager + Epilogue to build good logging habits before adopting more complex frameworks. Additional Resources What's Next? Up Next: Implementing Logging Now that you understand the logging framework options, you'll implement DataLogManager and Epilogue in your robot code to capture telemetry. Logging Options /pathplanner Adding PathPlanner /logging-implementation Implementing Logging Data Logging - Understanding What Happened Data logging captures robot telemetry, sensor values, and system state during operation. This data is essential for debugging issues, analyzing performance, tuning mechanisms, and understanding what happened during a match. Comprehensive logging transforms debugging from guesswork into data-driven problem solving. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-6 text-slate-600 dark:text-slate-300 mb-6 grid md:grid-cols-2 gap-6 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 font-bold text-red-600 dark:text-red-400 mb-3 text-lg list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 font-bold text-green-600 dark:text-green-400 mb-3 text-lg grid md:grid-cols-3 gap-6 Debug Faster Tune Better Improve Continuously info üí° Logging is a Competitive Advantage mb-3 text-sm text-slate-600 dark:text-slate-300 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 lg:grid-cols-3 gap-6 bg-primary-100 dark:bg-primary-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-primary-900 dark:text-primary-300 bg-green-100 dark:bg-green-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-green-900 dark:text-green-300 bg-orange-100 dark:bg-orange-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-orange-900 dark:text-orange-300 warning ‚ö†Ô∏è Balance Detail with Performance list-disc list-inside space-y-2 text-slate-600 dark:text-slate-300 bg-slate-50 dark:bg-slate-900 rounded-lg p-8 border border-slate-200 dark:border-slate-800 flex items-start gap-4 mb-6 bg-primary-600 text-white rounded-lg px-4 py-2 font-bold text-lg flex-1 text-2xl font-bold text-slate-900 dark:text-slate-100 mb-2 font-semibold text-slate-900 dark:text-slate-100 mb-3 mt-6 bg-green-600 text-white rounded-lg px-4 py-2 font-bold text-lg https://github.com/Mechanical-Advantage/AdvantageKit AdvantageKit GitHub Repository w-5 h-5 bg-orange-600 text-white rounded-lg px-4 py-2 font-bold text-lg bg-blue-600 text-white rounded-lg px-4 py-2 font-bold text-lg https://docs.wpilib.org/en/stable/docs/software/telemetry/robot-telemetry-with-annotations.html WPILib Epilogue Documentation overflow-x-auto w-full border-collapse border-b-2 border-slate-300 dark:border-slate-700 text-left p-4 font-semibold text-slate-900 dark:text-slate-100 border-b border-slate-200 dark:border-slate-800 p-4 font-medium text-slate-900 dark:text-slate-100 p-4 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 gap-6 mb-6 font-bold text-primary-600 dark:text-primary-400 mb-3 font-bold text-green-600 dark:text-green-400 mb-3 üí° Future Considerations grid md:grid-cols-2 gap-4 https://docs.wpilib.org/en/stable/docs/software/telemetry/datalog.html WPILib DataLogManager Documentation AdvantageKit GitHub https://github.com/Mechanical-Advantage/AdvantageScope AdvantageScope - Log Visualization https://v6.docs.ctr-electronics.com/ Phoenix 6 Documentation üìù Knowledge Check What is the primary advantage of comprehensive data logging in FRC? It makes the robot drive faster It allows you to replay exact robot state from any match and debug issues quickly It reduces battery consumption It improves WiFi connection Comprehensive logging captures all robot telemetry during matches, allowing teams to replay exact robot state, analyze performance, identify root causes of failures, and make data-driven tuning decisions - all critical for debugging between matches. What is the main difference between DataLogManager and AdvantageKit? DataLogManager is faster than AdvantageKit AdvantageKit provides deterministic replay capability while DataLogManager only provides visualization DataLogManager requires more code than AdvantageKit AdvantageKit only works with Python AdvantageKit provides deterministic replay capabilities - you can re-run robot code with logged data for time-travel debugging. DataLogManager only captures data for post-match visualization, without replay functionality. What makes WPILib Epilogue different from manual logging with SmartDashboard? Epilogue requires more boilerplate code Epilogue uses @Logged annotations to automatically generate logging code at compile time Epilogue is slower than SmartDashboard Epilogue only works with vision systems Epilogue uses @Logged annotations to automatically generate logging code at compile time, eliminating boilerplate SmartDashboard.put() calls while maintaining zero runtime overhead through compile-time code generation. What type of data should you prioritize logging for effective debugging? Only motor voltages Only camera images Sensor inputs, motor outputs, robot state, and control signals Only NetworkTables keys Effective logging captures sensor inputs (encoders, gyros, vision), motor outputs (voltage, current), robot state (pose, subsystem states), and control signals (PID setpoints, errors) - providing complete context for debugging. Why might excessive logging impact robot performance? Logging makes motors spin slower High-frequency data logging can consume network bandwidth, CPU cycles, and storage space Logging disables the gyroscope Logging prevents autonomous mode from working Excessive logging (especially high-frequency strings or large data) can spam NetworkTables bandwidth, increase CPU overhead in control loops, and create very large log files. Efficient binary formats and appropriate sample rates are essential. bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/logging-options",
    category: "Workshop 2",
    tags: [
      "logging-options",
      "frc",
      "robot",
      "pid",
      "motor",
      "subsystem",
      "control",
      "hardware",
      "ctre",
      "java",
      "workshop",
    ],
  },
  {
    id: "mechanism-cad",
    title: "Mechanism CAD",
    description:
      "3D CAD models and visualization of robot mechanisms used in the workshop.",
    content:
      "(null); const armModelRef = useRef (null); return ( Interactive 3D Models Flywheel Mechanism This 3D model represents the mechanism you'll be programming in this workshop. Use your mouse to orbit around the model, zoom in/out, and examine the design from different angles. üì¶ Download STL üîß Download STP üñ®Ô∏è Bambu Files - Coming Soon Arm Mechanism An Arm mechanism for Workshop programming. This arm mechanism demonstrates precise positioning and control concepts that are essential in FRC robotics. STL Files Standard format for 3D printing. Compatible with most slicers including PrusaSlicer, Cura, and Bambu Studio. STP Files CAD format for editing and modification. Opens in Fusion 360, SolidWorks, and other CAD software. What's Next? Ready for Programming!!! Now that you have a mechanism, you're ready to move on to connecting and configuring the code to make this work. We'll cover motors, sensors, and controllers needed to bring this CAD model to life. use client Mechanism CAD /prerequisites Prerequisites /hardware Hardware Setup Mechanism CAD - 3D Model Exploration Before diving into programming, we first need a physical mechanism. If you do not have a previous robot or mechanism below are 3D models of mechanisms you can build affordably. Interactive 3D model of the Flywheel mechanism. flex flex-col gap-8 -mx-4 sm:-mx-6 md:-mx-8 lg:-mx-12 xl:-mx-16 text-3xl font-bold text-slate-900 dark:text-slate-100 px-4 sm:px-6 md:px-8 lg:px-12 xl:px-16 bg-slate-50 dark:bg-slate-900 rounded-lg p-4 md:p-8 shadow-lg border border-slate-200 dark:border-slate-800 mx-4 sm:mx-6 md:mx-8 lg:mx-12 xl:mx-16 flex flex-col gap-6 w-full /cad/HTTI Mechanism v2 - Shooter Mode.gltf w-full h-64 sm:h-80 md:h-96 lg:h-[600px] shadow-lg text-center space-y-4 text-xl font-semibold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 max-w-2xl flex gap-3 /cad/HTTI Mechanism v2 - Shooter Mode.stl flex-1 bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-lg text-center font-medium transition-colors /cad/HTTI Mechanism v2 - Shooter Mode.stp flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg text-center font-medium transition-colors bg-slate-300 dark:bg-slate-700 text-slate-500 dark:text-slate-400 px-4 py-2 rounded-lg text-center font-medium cursor-not-allowed mt-2 /cad/HTTI Mechanism v2 - Arm Mode.gltf /cad/HTTI Mechanism v2 - Arm Mode.stl /cad/HTTI Mechanism v2 - Arm Mode.stp px-4 sm:px-6 md:px-8 lg:px-12 xl:px-16 info üìã File Format Guide grid md:grid-cols-2 gap-4 text-sm font-bold text-blue-800 dark:text-blue-300 mb-2 text-blue-700 dark:text-blue-300 mt-8 px-4 sm:px-6 md:px-8 lg:px-12 xl:px-16 Shooter Mechanism flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-primary-200 dark:border-primary-900 flex items-start space-x-4 flex-shrink-0 flex items-center justify-center w-12 h-12 bg-primary-100 dark:bg-primary-900/50 rounded-lg w-6 h-6 text-primary-600 dark:text-primary-400 none currentColor 0 0 24 24 round M13 10V3L4 14h7v7l9-11h-7z text-lg font-semibold text-primary-900 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300",
    url: "/mechanism-cad",
    category: "Resources",
    tags: ["mechanism-cad", "workshop", "control", "frc", "hardware", "robot"],
  },
  {
    id: "mechanism-setup",
    title: "Mechanism Setup",
    description:
      "Configuring specific robot mechanisms and their control systems.",
    content:
      '("arm"); return ( Warning: Stop Code Before Hardware Setup stop any running code the "CANivore USB" setting in TunerX. This ensures proper communication with physical hardware during testing and configuration. Steps: Stop any running robot code ‚Üí Open TunerX ‚Üí Go to CANivore settings ‚Üí Enable "CANivore USB" Setup Steps by Mechanism ü¶æ Arm Mechanism ‚ö° Flywheel Mechanism üìù Important Note: Encoder Replacement If you replace your encoder with a new one, you will need to repeat these setup steps to ensure proper direction and zero position configuration. 1Ô∏è‚É£ Encoder Direction You\'ll need to make sure your encoder is configured correctly. With the device facing you, as shown in the following picture, please make sure that the encoder position increases as you rotate the arm counterclockwise. Expected Behavior: ‚Ä¢ Counterclockwise rotation ‚Üí Position increases ‚Ä¢ Clockwise rotation ‚Üí Position decreases üîß Implementation Sequence Rotate Counter-Clockwise Manually rotate the mechanism counter-clockwise and observe if the encoder position increases. Fix Direction if Needed If position goes down instead of up, go to "Info" ‚Üí "Sensor Direction" ‚Üí press "Apply" button to invert the encoder direction. Zero the Encoder Put arm to zero position, then in TunerX go to "Info" ‚Üí press "0 encoder" button ‚Üí press "Apply" button. 2Ô∏è‚É£ Verifying Motor Setup You\'ll want to make sure your motor is spinning in the expected direction. If the motor is getting positive voltage, it should be spinning counterclockwise. You can check this through tuner, with the device facing you as in the following picture. üîß Motor Direction Verification Expected: Positive voltage should move the mechanism in the "positive" direction (counter-clockwise for arms). Positive motor voltage ‚Üí positive encoder change, negative motor voltage ‚Üí negative encoder change. ) : ( 1Ô∏è‚É£ Verifying Motor Setup You\'ll want to make sure your flywheel motors are spinning in the expected direction. If the motor is getting positive voltage, both motors should spin in the same direction (leader-follower setup). You can check this through tuner. ‚Ä¢ Leader and follower motors spin together ‚Ä¢ Positive voltage ‚Üí Shooting Both motors should rotate smoothly in the same direction with consistent speed. Follower motor should mirror leader motor movements with minimal lag. ‚úÖ Ready for Control Once your mechanism moves in the correct direction and provides accurate feedback (encoder for arms, motor consistency for flywheels), you\'re ready to implement advanced control algorithms. üí° Next Step: With verified hardware setup, we can now implement PID control for precise mechanism control. The control algorithm will use sensor feedback to automatically reach target positions or velocities. use client arm flywheel Mechanism Setup /running-program Running Program /pid-control PID Control Mechanism Setup - Verifying Hardware Configuration Before implementing advanced control algorithms, we need to verify that motors and encoders are working correctly. This ensures proper direction, zeroing, and basic functionality. Always verify hardware setup before adding control algorithms. Otherwise you will be debugging control issues when the problem is hardware configuration. bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-6 flex items-start gap-3 w-6 h-6 text-red-600 dark:text-red-400 flex-shrink-0 mt-0.5 none currentColor 0 0 24 24 round M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z text-lg font-bold text-red-800 dark:text-red-300 mb-2 text-red-700 dark:text-red-300 mb-3 bg-red-100 dark:bg-red-900/30 p-3 rounded border border-red-200 dark:border-red-700 text-red-800 dark:text-red-200 text-sm flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 card border-b border-[var(--border)] flex border-primary-600 text-primary-600 border-transparent text-[var(--muted-foreground)] hover:text-[var(--foreground)] p-6 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6 flex items-start gap-4 w-6 h-6 text-blue-600 dark:text-blue-400 flex-shrink-0 mt-1 M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z text-lg font-bold text-blue-800 dark:text-blue-300 mb-2 text-blue-700 dark:text-blue-300 card p-8 text-2xl font-bold text-[var(--foreground)] mb-6 grid grid-cols-2 gap-6 mb-6 text-[var(--muted-foreground)] mb-4 bg-primary-50 dark:bg-primary-950/30 p-4 rounded-lg font-semibold text-primary-900 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300 space-y-1 text-sm flex flex-row gap-8 justify-center items-center mb-8 /images/setup/unit_circle_degrees_rotations_decimal.png Unit circle showing counterclockwise rotation direction rounded-lg /images/setup/counter-clockwise.png Counterclockwise rotation direction text-xl font-bold text-[var(--foreground)] mb-4 space-y-4 flex items-center gap-4 p-4 bg-primary-50 dark:bg-primary-950/20 rounded-lg bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-700 dark:text-primary-300 text-primary-600 dark:text-primary-400 text-sm flex items-center gap-4 p-4 bg-primary-100 dark:bg-primary-900/30 rounded-lg bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-800 dark:text-primary-200 text-primary-700 dark:text-primary-300 text-sm flex items-center gap-4 p-4 bg-primary-200 dark:bg-primary-800/40 rounded-lg bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold font-bold text-primary-900 dark:text-primary-100 text-primary-800 dark:text-primary-200 text-sm https://www.youtube.com/embed/mjGn3y19eUc Encoder Setup and Verification accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full aspect-video rounded-lg grid grid-cols-2 gap-6 mb-8 items-start text-[var(--muted-foreground)] Counterclockwise rotation direction for motor verification rounded-lg -mt-0 https://www.youtube.com/embed/iQqR1Wxptzg Motor Testing mt-8 text-xl font-bold text-learn-600 mb-4 grid md:grid-cols-2 gap-6 Positive Voltage Test Apply +6V to your motor and observe movement direction. bg-[var(--muted)] text-[var(--muted-foreground)] p-3 rounded border border-[var(--border)] text-xs text-[var(--muted-foreground)] Encoder Consistency Verify encoder readings match motor movement. grid grid-cols-3 gap-6 mb-8 col-span-2 flex w-full justify-center /images/mechanisms/flywheel.png Flywheel mechanism for motor verification Apply +6V to your flywheel and observe rotation. Leader-Follower Check Verify follower motor tracks leader motor exactly. bg-[var(--muted)] border border-[var(--border)] rounded-lg p-6 bg-indigo-50 dark:bg-indigo-950/30 p-4 rounded mt-4 text-indigo-800 dark:text-indigo-300 text-sm üìù Knowledge Check When rotating the arm counter-clockwise while facing the encoder, what should happen to the encoder position? The encoder position should decrease The encoder position should increase The encoder position should stay the same The encoder direction doesn Counter-clockwise rotation should cause the encoder position to increase. If it decreases instead, you need to invert the encoder direction in TunerX. What is the purpose of zeroing the encoder on an arm mechanism? To set the maximum position limit To calibrate the motor speed To establish a reference point at a known position (typically horizontal or down) To test if the encoder is working Zeroing the encoder establishes a reference point at a known position. For arms, this is typically done with the arm in a horizontal or down position, so all future positions are measured relative to this starting point. What should you do BEFORE performing hardware setup tasks in TunerX? Calibrate the motors at full speed Stop any running code and turn ON setting Reset all motor controllers to factory defaults Disconnect the battery Before hardware setup, you must stop any running robot code and turn ON the setting in TunerX. This ensures proper communication with physical hardware during testing and configuration. When testing motor direction with positive voltage, what is the expected behavior for an arm mechanism? The motor should spin at maximum speed The motor should move the mechanism counter-clockwise (in the positive direction) The motor should remain stationary The motor direction doesn Positive voltage should move the mechanism in the positive direction, which is counter-clockwise for arms. This ensures consistency between motor commands and encoder readings. What happens if you replace your encoder with a new one? Nothing - it will work automatically You only need to update the device ID in code You need to repeat the encoder direction and zeroing setup steps The old configuration transfers to the new encoder If you replace your encoder with a new one, you must repeat the setup steps to ensure proper direction configuration and zero position. Each encoder needs individual setup and calibration.',
    url: "/mechanism-setup",
    category: "Workshop 1",
    tags: ["mechanism-setup", "hardware", "robot", "motor", "control", "pid"],
  },
  {
    id: "motion-magic",
    title: "Motion Magic",
    description:
      "Advanced motion profiling using CTRE's Motion Magic for smooth, controlled movements.",
    content:
      'Understanding Motion Magic Profiles üìà Trapezoidal Profile Motion Magic creates a trapezoidal velocity profile with three phases: 1. Acceleration: 2. Cruise: 3. Deceleration: ‚öôÔ∏è Key Parameters Motion Magic Cruise Velocity Maximum velocity during cruise phase (rotations/second) Motion Magic Acceleration Rate of acceleration/deceleration (rotations/second¬≤) Motion Magic Jerk Rate of change of acceleration (rotations/second¬≥) üìö Official Motion Magic Documentation For complete Motion Magic reference, configuration examples, and advanced tuning techniques: ü¶æ Position Mechanisms (Arms, Elevators) 1. Calculate Maximum Velocity: Motor Speed: Krakens run around 100 RPS at maximum Efficiency: Best used around 80% efficiency Gear Ratio: Our 25:1 arm gearing reduces speed maxVel = (100 / 25) * 0.8 = 3.2 RPS 2. Set Motion Magic Parameters: Cruise Velocity: Use calculated max velocity cruiseVel = 3.0; // conservative start Acceleration: Start with 2x cruise velocity for smooth motion Competition: Typically end up with 4x to 10x cruise velocity acceleration = cruiseVel * 2.0; // smooth start üå™Ô∏è Velocity Mechanisms (Flywheels, Shooters) Direct Drive: Using Kraken encoder directly on flywheel cruiseVel = 100 * 0.8 = 80 RPS cruiseVel = 80.0; // based on motor efficiency üí° Why This Method Works: By calculating cruise velocity based on motor specifications and efficiency, you set realistic motion limits that prevent oscillation and ensure smooth, achievable motion profiles. Starting with 2x acceleration provides smooth motion, while competition applications often require 4x to 10x cruise velocity for faster response. üìπ Motion Magic Tuning Tutorial Watch this comprehensive tutorial on Motion Magic tuning techniques, parameter selection, and optimization strategies: Motion Magic Implementation in Code 25:1 Gearing: Krakens run ~100 RPS, so 4 RPS theoretical max at output", "‚Ä¢ Cruise Velocity (2.0): Conservative start - can reach 4 RPS but load may reduces performance", "‚Ä¢ Acceleration (8.0): How quickly to reach cruise speed", "‚Ä¢ Jerk (80.0): Smoothness of acceleration changes", "‚Ä¢ MotionMagicVoltage: Replaces PositionVoltage for profiled control", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ Setpoint Detection: Checks both position AND velocity", "‚Ä¢ Smooth Motion: Eliminates jerky arm movements", "‚Ä¢ Mechanical Safety: Reduces stress on gearboxes", "‚Ä¢ Predictable Timing: How quickly to reach target velocity", "‚Ä¢ Jerk: MotionMagicVelocity: Replaces VelocityVoltage for profiled control", "‚Ä¢ Velocity Targeting: Precise speed control with smooth ramping", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ Checks both velocity AND acceleration", "‚Ä¢ Eliminates sudden flywheel speed changes", "‚Ä¢ Reduces stress on motors and mechanisms", "‚Ä¢ When to Use Basic PID: Simple positioning tasks Continuous control (like maintaining angle) When speed of response is critical Mechanisms with very low inertia When to Use Motion Magic: Large, heavy mechanisms (arms, elevators) When smooth motion is important Preventing mechanical stress Predictable motion timing needed Motion Magic /pid-control PID Control /vision-shooting Vision-Based Shooting Motion Magic - Profiled Motion Control Motion Magic builds on PID control by adding smooth acceleration and deceleration profiles. This prevents jerky movements and reduces mechanical stress while maintaining precise positioning. Motion Magic automatically generates smooth velocity profiles to reach target positions with controlled acceleration. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-2 gap-6 bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-xl font-bold text-[var(--foreground)] mb-4 text-[var(--foreground)] mb-4 text-sm space-y-2 bg-slate-50 dark:bg-slate-900 p-3 rounded text-[var(--foreground)] text-[var(--muted-foreground)] text-sm bg-[var(--muted)] rounded-lg p-6 border-l-4 border-blue-500 space-y-3 font-bold text-[var(--foreground)] text-[var(--foreground)] mb-4 https://v6.docs.ctr-electronics.com/en/latest/docs/api-reference/device-specific/talonfx/motion-magic.html CTRE Motion Magic API Reference w-5 h-5 ‚öôÔ∏è Motion Magic Tuning Steps info bg-blue-50 dark:bg-blue-950 p-4 rounded-lg border border-blue-200 dark:border-blue-800 font-semibold text-blue-800 dark:text-blue-200 mb-3 flex items-center space-y-4 font-semibold text-[var(--foreground)] mb-2 text-sm text-[var(--foreground)] space-y-2 list-disc list-inside bg-slate-50 dark:bg-slate-800 px-1 rounded bg-green-50 dark:bg-green-950 p-4 rounded-lg border border-green-200 dark:border-green-800 font-semibold text-green-800 dark:text-green-200 mb-3 flex items-center bg-[var(--muted)] p-4 rounded mt-4 border-l-4 border-[var(--border)] text-[var(--foreground)] text-sm flex flex-col gap-6 text-2xl font-bold text-slate-900 dark:text-slate-100 aspect-video rounded-lg overflow-hidden https://www.youtube.com/embed/7I7r9p1RBZI Motion Magic Tuning Tutorial w-full h-full üîß Motion Magic Configuration Example java Motion Magic Setup in Subsystem Constructor Workshop Implementation: Motion Magic ‚Ä¢ PID position control with PositionVoltage ‚Ä¢ Instant acceleration to target ‚Ä¢ Potential mechanical stress from jerky movements ‚Ä¢ No velocity planning or profiling ‚Ä¢ Abrupt start/stop motions ‚Ä¢ Motion Magic profiled motion with MotionMagicVoltage ‚Ä¢ Smooth acceleration and deceleration curves ‚Ä¢ Reduced mechanical stress and wear ‚Ä¢ Configurable cruise velocity and acceleration ‚Ä¢ Professional, smooth motion profiles Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 4-MotionMagic Arm.java Motion Magic Example Params for 25:1 Arm ‚Ä¢ <strong>25:1 Gearing:</strong> Krakens run ~100 RPS, so 4 RPS theoretical max at output ‚Ä¢ <strong>Cruise Velocity (2.0):</strong> Conservative start - can reach 4 RPS but load may reduces performance ‚Ä¢ <strong>Acceleration (8.0):</strong> How quickly to reach cruise speed ‚Ä¢ <strong>Jerk (80.0):</strong> Smoothness of acceleration changes ‚Ä¢ <strong>MotionMagicVoltage:</strong> Replaces PositionVoltage for profiled control Enhanced Features ‚Ä¢ <strong>Setpoint Detection:</strong> Checks both position AND velocity ‚Ä¢ <strong>Smooth Motion:</strong> Eliminates jerky arm movements ‚Ä¢ <strong>Mechanical Safety:</strong> Reduces stress on gearboxes ‚Ä¢ <strong>Predictable Timing:</strong> Known motion duration Motion Magic gives us professional-grade position control! Next, we ‚Ä¢ PID velocity control with VelocityVoltage ‚Ä¢ Instant acceleration to target speed ‚Ä¢ Potential mechanical stress from sudden velocity changes ‚Ä¢ Motion Magic profiled velocity with MotionMagicVelocity ‚Ä¢ Configurable acceleration and jerk for velocity changes ‚Ä¢ Professional, smooth velocity transitions src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java Motion Magic Parameters ‚Ä¢ <strong>Acceleration:</strong> How quickly to reach target velocity ‚Ä¢ <strong>Jerk:</strong> Smoothness of acceleration changes ‚Ä¢ <strong>MotionMagicVelocity:</strong> Replaces VelocityVoltage for profiled control ‚Ä¢ <strong>Velocity Targeting:</strong> Precise speed control with smooth ramping ‚Ä¢ <strong>Setpoint Detection:</strong> Checks both velocity AND acceleration ‚Ä¢ <strong>Smooth Motion:</strong> Eliminates sudden flywheel speed changes ‚Ä¢ <strong>Mechanical Safety:</strong> Reduces stress on motors and mechanisms ‚Ä¢ <strong>Predictable Timing:</strong> Known velocity change duration Motion Magic gives us professional-grade velocity control! Next, we ‚öñÔ∏è Motion Magic vs Basic PID warning text-sm text-[var(--foreground)] space-y-1 list-disc list-inside üìù Knowledge Check What is the primary benefit of Motion Magic over basic PID control? It uses less battery power It adds smooth acceleration and deceleration profiles It eliminates the need for feedforward gains It makes motors run faster Motion Magic builds on PID by adding smooth acceleration and deceleration profiles, preventing jerky movements and reducing mechanical stress while maintaining precise positioning. What are the three phases of a Motion Magic trapezoidal velocity profile? Start, middle, end Acceleration, cruise, deceleration Ramp up, hold, ramp down Fast, slow, stop Motion Magic creates a trapezoidal profile with three phases: acceleration (ramp up to cruise velocity), cruise (maintain constant max velocity), and deceleration (smoothly brake to target). What does Motion Magic Cruise Velocity parameter control? The minimum velocity the mechanism can achieve The maximum velocity during the cruise phase The rate of acceleration The total time to reach the target Motion Magic Cruise Velocity sets the maximum velocity maintained during the cruise phase of the motion profile, measured in rotations per second. For a mechanism with 25:1 gearing and a Kraken motor (100 RPS max), what would be a conservative starting cruise velocity at 80% efficiency? 100 RPS 25 RPS 3.2 RPS 0.8 RPS With 25:1 gearing, the output is 100 RPS / 25 = 4 RPS theoretical max. At 80% efficiency, this gives 4 * 0.8 = 3.2 RPS. A conservative start would be around 3.0 RPS. What is the recommended starting value for Motion Magic acceleration? Equal to cruise velocity 2x cruise velocity for smooth motion 10x cruise velocity for fastest response Half of cruise velocity for safety Starting with 2x cruise velocity provides smooth motion. During competition tuning, teams typically increase this to 4x to 10x cruise velocity for faster response. When should you use Motion Magic instead of basic PID? For continuous angle control like maintaining heading For large, heavy mechanisms requiring smooth motion When speed of response is more important than smoothness For mechanisms with very low inertia Motion Magic is ideal for large, heavy mechanisms (arms, elevators) where smooth motion is important, preventing mechanical stress and providing predictable motion timing.',
    url: "/motion-magic",
    category: "Workshop 1",
    tags: [
      "motion-magic",
      "motor",
      "control",
      "pid",
      "ctre",
      "java",
      "subsystem",
      "workshop",
      "frc",
      "robot",
    ],
  },
  {
    id: "home",
    title: "Gray Matter Coding Workshop - Home",
    description:
      "Learn FRC's best programming practices to build a robot good enough to win events.",
    content:
      "Hemlock's Gray Matter - Team 5712 Coding Workshop Learn FRC's best programming practices to build a robot good enough to win events. Master code architecture, subsystems, PID tuning, libraries, and more! Ready to build competition-winning robot code? Begin Your FRC Journey Hands-on ¬∑ Interactive What We're Programming This workshop uses two fundamental FRC mechanisms to teach universal programming concepts that apply to all robot systems. Learn motor control, PID tuning, encoder feedback, and motion profiling with these competition-proven designs. Arm Position Control Program precise arm positioning using PID control, encoder feedback, and Motion Magic for smooth, controlled movements to scoring positions. Flywheel Velocity Control Master velocity control for consistent shooting performance using feedforward control and velocity PID for rapid spin-up and accuracy. Special thanks to: The Team: Joe Lockwood, Josh Bacon, Chris Bale, Alex Haltom, and Team 5712 Ethan Shannon and Team 5216 max-w-6xl mx-auto px-4 py-12 flex flex-col gap-8 text-center flex flex-col gap-8 text-3xl md:text-4xl font-bold text-slate-900 dark:text-slate-100 text-center text-xl text-slate-600 dark:text-slate-300 max-w-3xl mx-auto max-w-lg mx-auto text-center text-slate-600 dark:text-slate-400 mb-6 text-lg /introduction inline-flex flex-col items-center bg-primary-600 text-white px-12 py-5 rounded-xl font-bold hover:bg-primary-700 transition-all duration-200 transform hover:scale-105 shadow-lg hover:shadow-xl text-2xl text-sm font-normal opacity-90 mt-1 bg-slate-50 dark:bg-slate-900 rounded-lg p-8 shadow-lg border border-slate-200 dark:border-slate-800 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-6 text-center text-slate-600 dark:text-slate-300 text-center mb-4 max-w-3xl mx-auto text-slate-600 dark:text-slate-300 text-center mb-8 max-w-3xl mx-auto grid md:grid-cols-2 gap-8 bg-white dark:bg-slate-800 rounded-lg p-6 shadow-md border border-slate-200 dark:border-slate-700 mb-4 /images/mechanisms/arm.png Competition robot arm with rotational joint controlled by CTRE Kraken motor, demonstrating position control for FRC scoring mechanisms w-full h-48 object-cover rounded-lg shadow-sm bg-primary-100 dark:bg-primary-900/20 p-4 rounded-lg text-xl font-semibold text-primary-900 dark:text-primary-300 mb-2 text-primary-700 dark:text-primary-300 text-sm /images/mechanisms/flywheel.png High-speed flywheel shooter mechanism for launching game pieces, demonstrating velocity control and feedforward techniques in FRC bg-green-100 dark:bg-green-900/20 p-4 rounded-lg text-xl font-semibold text-green-900 dark:text-green-300 mb-2 text-green-700 dark:text-green-300 text-sm bg-[var(--card)] text-[var(--foreground)] p-8 rounded-lg text-center space-y-6 space-y-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 items-center justify-items-center https://store.ctr-electronics.com/ _blank noopener noreferrer w-full max-w-48 h-32 flex items-center justify-center bg-white dark:bg-slate-800 rounded-lg p-2 shadow-sm hover:shadow-md transition-shadow cursor-pointer /images/sponsors/ctre-logo.jpg CTR Electronics Logo max-w-full max-h-full object-contain https://michauto.org/ /images/sponsors/MichAuto Logo 600x600.png MichAuto Logo https://www.michiganbusiness.org/ofme/ /images/sponsors/OFME-Logo.png Michigan Office of Future Mobility and Electrification Logo https://lockwoodstemcenter.hemlockps.com/home /images/sponsors/lockwood-stem-center-logo.png Lockwood STEM Center Logo text-lg font-semibold text-slate-900 dark:text-slate-100 mb-2 text-slate-600 dark:text-slate-300",
    url: "/",
    category: "General",
    tags: ["workshop", "frc", "robot", "pid", "motor", "control", "ctre"],
  },
  {
    id: "pathplanner",
    title: "Adding PathPlanner",
    description:
      "Integrating PathPlanner for autonomous path planning and trajectory following.",
    content:
      "The swerve drivetrain generated by Phoenix Tuner X doesn't include the PathPlanner integration by default. The Workshop-Code repository includes this integration in Pull Request #7, which shows the complete swerve and PathPlanner setup. Workshop Code Implementation SwerveWithPathPlanner The swerve code includes several key files generated by Phoenix Tuner X: CommandSwerveDrivetrain: Main drivetrain subsystem with control methods TunerConstants: All configuration values (CAN IDs, gear ratios, dimensions) RobotContainer: Drive command bindings and controller setup generated/ folder: Low-level module and drive train implementations What is PathPlanner? PathPlanner is a motion planning tool specifically designed for FRC robots. It provides a graphical interface for creating autonomous paths with velocity constraints, rotation control, and event markers. Key Features Visual Path Editor: Drag-and-drop waypoints on a field image Holonomic Support: Independent control of translation and rotation Constraints: Velocity, acceleration, and angular velocity limits Event Markers: Trigger commands at specific points along the path Named Commands: Reusable command definitions for autonomous Auto Builder: Compose complex autos from multiple paths Why PathPlanner? FRC-Specific: Built for WPILib and FRC field layouts Time-Saving: Visual editor is faster than manual tuning Repeatable: Paths saved as JSON files in your repo Team Friendly: Non-programmers can help create paths Proven: Used by top FRC teams in competition Active Development: Regular updates and FRC community support Installing PathPlanner Step 1: Download PathPlanner GUI Download the PathPlanner desktop application for your operating system from the official releases page: Step 2: Add PathPlanner as a Vendor Dependency Follow the steps in the PathPlanner Getting Started Guide to add PathPlanner as a vendor dependency. Step 3: Configure AutoBuilder The CommandSwerveDrivetrain generated by Phoenix Tuner X automatically configures PathPlanner's AutoBuilder. You can see this in the constructor: Creating Your First Path Opening Your Project in PathPlanner Launch the PathPlanner GUI application Click \"Open Project\" and navigate to your robot project root directory src/main/deploy/pathplanner directory Update robot configuration in the PathPlanner settings to match your robot's physical parameters Path Creation Workflow Add Waypoints: Click on the field to place waypoints. The first point is your starting position, and subsequent points define the path. Adjust Heading: For swerve drive, you can independently control the robot's heading at each waypoint. Drag the rotation handle to set the desired orientation. Set Constraints: Define velocity and acceleration limits for different segments of the path. This is useful for slowing down around tight turns. Add Event Markers: Place markers along the path to trigger commands (e.g., intake game pieces, shoot, etc.) NamedCommands Register named commands that can be triggered by event markers in your paths: PathPlanner Tips & Best Practices Start with simple paths and gradually add complexity Use fewer waypoints for smoother paths (let PathPlanner interpolate) Test paths in simulation before running on real robot Save multiple versions of paths for testing different strategies Don't set constraints too aggressively - allow margins for error Always verify starting pose matches path starting point deploy/pathplanner Test event marker timing - they execute at specific path points PathPlanner Integration Complete! You now have PathPlanner integrated with your swerve drivetrain and understand how to create autonomous paths. Key takeaways: PathPlanner provides visual path creation for autonomous routines CTRE swerve generator automatically configures PathPlanner integration Holonomic support allows independent translation and rotation Event markers enable command execution at specific path points Named commands create reusable actions for autonomous Workshop Code PRs demonstrate progressive implementation What's Next? Up Next: Logging Options With autonomous paths configured, you'll learn about data logging strategies to capture telemetry and debug your robot's performance. Adding PathPlanner /swerve-drive-project Creating a Swerve Drive Project /logging-options Logging Options PathPlanner for Autonomous Navigation PathPlanner is a motion profile generator for FRC robots, providing a GUI for creating complex autonomous paths and seamlessly integrating with your swerve drivetrain. The CTRE swerve generator automatically configures PathPlanner integration, making autonomous development straightforward. PathPlanner enables visual path creation with constraints, events, and holonomic control for swerve drivetrains. info PathPlanner Integration mb-2 flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 text-primary-600 underline hover:no-underline hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300 font-medium https://github.com/CrossTheRoadElec/Phoenix6-Examples/tree/main/java/SwerveWithPathPlanner üìÅ CommandSwerveDrivetrain.java space-y-4 Hemlock5712/Workshop-Code 1-Swerve src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java üéÆ RobotContainer.java src/main/java/frc/robot/RobotContainer.java üîç Exploring the Swerve Implementation mb-3 list-disc list-inside space-y-2 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 gap-6 bg-primary-50 dark:bg-primary-950/30 p-6 rounded-lg border border-slate-200 dark:border-slate-800 text-lg font-semibold text-slate-900 dark:text-slate-100 mb-4 space-y-2 text-sm text-slate-600 dark:text-slate-300 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 space-y-6 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-4 text-slate-600 dark:text-slate-300 mb-4 https://github.com/mjansen4857/pathplanner/releases PathPlanner Releases https://pathplanner.dev/pplib-getting-started.html PathPlanner Installation Guide CommandSwerveDrivetrain.java java Failed to load PathPlanner config and configure AutoBuilder space-y-3 text-slate-600 dark:text-slate-300 mb-4 https://pathplanner.dev/robot-config.html PathPlanner Settings space-y-4 text-slate-600 dark:text-slate-300 font-semibold mb-2 text-sm Registered Named Commands intakeNote shootNote stopIntake tip Path Creation list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 warning Common Pitfalls bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4 https://pathplanner.dev/home.html PathPlanner Official Documentation üìù Knowledge Check What is the primary purpose of PathPlanner in FRC? To control robot motors directly To create visual autonomous paths with velocity constraints and event markers To tune PID controllers To monitor robot battery voltage PathPlanner is a motion planning tool that provides a graphical interface for creating autonomous paths with velocity constraints, rotation control, and event markers. It What advantage does PathPlanner Faster maximum speed Independent control of translation and rotation Reduced power consumption Automatic motor tuning Holonomic support allows independent control of translation (moving in X and Y directions) and rotation. This means a swerve robot can drive in one direction while simultaneously rotating to face another direction, which is crucial for efficient autonomous routines. How do you add PathPlanner as a dependency to your robot project? Download it from the Microsoft Store Add it as a WPILib vendor dependency using the online JSON URL Install it through Phoenix Tuner X Copy files manually into your project PathPlanner is added to your robot project as a WPILib vendor dependency. You follow the installation guide to add the vendor JSON URL, which automatically downloads and configures the PathPlanner library in your project. What are NamedCommands used for in PathPlanner? Naming your autonomous routines Creating reusable commands that can be triggered by event markers along paths Labeling robot subsystems Defining motor controller names NamedCommands are registered commands that can be triggered by event markers placed along your autonomous paths. For example, you might register and commands that execute at specific points during path following. Where are PathPlanner path files stored in your robot project? src/main/java/frc/robot/paths/ src/main/deploy/pathplanner/ build/pathplanner/ C:/Users/Public/PathPlanner/ PathPlanner stores path files in the src/main/deploy/pathplanner/ directory of your robot project. These JSON files are deployed to the roboRIO and should be committed to version control so the entire team can access them.",
    url: "/pathplanner",
    category: "Workshop 2",
    tags: [
      "pathplanner",
      "workshop",
      "subsystem",
      "control",
      "command",
      "frc",
      "robot",
      "ctre",
      "java",
      "pid",
      "motor",
    ],
  },
  {
    id: "pid-control",
    title: "PID Control",
    description:
      "Understanding and implementing PID control for precise robot positioning and movement.",
    content:
      'Understanding PID Components P - Proportional Definition: "The amount of output to apply per unit of error in the system" Error = Target - Current P_Output = kP √ó Error Behavior: Larger error = stronger correction. Provides immediate response but may cause oscillation. I - Integral "The amount of output to apply per unit of error for every second of that error" Accumulated_Error += Error √ó dt I_Output = kI √ó Accumulated_Error Eliminates steady-state error by accumulating past errors over time. Note: The integral term can lead to "windup," which may make your mechanism unstable. In most FRC applications, you can leave the integral term at zero. D - Derivative "The amount of output to apply per change in error over time" Error_Rate = (Error - Last_Error) / dt D_Output = kD √ó Error_Rate Reduces overshoot by predicting future error trends and dampening response. Feedforward gains help the system by predicting the required output based on the target, rather than reacting to error. Constant output to overcome friction and get the mechanism moving. Compensates for gravitational forces acting on the mechanism. Output applied per target velocity to maintain smooth motion. Output applied per target acceleration for responsive movement. For detailed PID tuning instructions, step-by-step processes, and mechanism-specific guidance: üìπ PID and Feedforward Tuning Tutorial Watch this comprehensive tutorial on PID and feedforward tuning techniques, practical tuning steps, and optimization strategies: PID Implementation in Code PositionVoltage: Replaces VoltageOut for closed-loop control", "‚Ä¢ Slot0 Config: PID and feedforward gains configuration", "‚Ä¢ Target Setting: setTargetPosition() method for precise control", ], rightTitle: "Gain Values Used", rightItems: [ "‚Ä¢ kP = 24.0: Strong proportional response", "‚Ä¢ kD = 0.1: Small derivative for damping", "‚Ä¢ kS = 0.25: Static friction compensation", "‚Ä¢ kG = 0.12: VelocityVoltage: Replaces VoltageOut for closed-loop velocity control", "‚Ä¢ PID and feedforward gains configuration for velocity", "‚Ä¢ setTargetVelocity() method for precise speed control", ], rightTitle: "Gain Values Used", rightItems: [ "‚Ä¢ kP: Proportional response for velocity error", "‚Ä¢ kI: Integral gain to eliminate steady-state velocity error", "‚Ä¢ kS: Static friction compensation for startup", "‚Ä¢ kV: PID Control /mechanism-setup Mechanism Setup /motion-magic Motion Magic PID Control - Precise Position Control PID (Proportional-Integral-Derivative) control replaces imprecise voltage commands with accurate, feedback-driven position control. Essential for mechanisms that need to hit specific targets. PID uses sensor feedback to automatically adjust motor output to reach and maintain target positions. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-3 gap-6 bg-[var(--muted)] dark:bg-slate-700/20 rounded-lg p-6 border-l-4 border-red-500 text-xl font-bold text-[var(--foreground)] mb-4 text-[var(--foreground)] mb-4 text-sm bg-[var(--muted)] text-[var(--muted-foreground)] p-4 rounded mb-3 text-xs text-[var(--foreground)] text-sm bg-[var(--muted)] dark:bg-slate-700/20 rounded-lg p-6 border-l-4 border-yellow-500 text-[var(--foreground)] text-sm mb-3 bg-[var(--muted)] dark:bg-slate-700/20 rounded-lg p-6 border-l-4 border-blue-500 info ‚ö° Feedforward Gains mb-4 grid md:grid-cols-4 gap-4 kS - Static Always kG - Gravity Arms/Elevators kV - Velocity Flywheels/Intakes kA - Acceleration High Inertia Mechanisms üìö Complete PID Tuning Guide https://phoenixpro-documentation--161.org.readthedocs.build/en/161/docs/application-notes/manual-pid-tuning.html CTRE Manual PID Tuning Guide w-5 h-5 flex flex-col gap-6 text-2xl font-bold text-slate-900 dark:text-slate-100 bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-[var(--foreground)] mb-4 aspect-video rounded-lg overflow-hidden https://www.youtube.com/embed/Pt7SBFfl3oM PID and Feedforward Tuning Tutorial w-full h-full üîß PID Configuration Example java PID Setup in Subsystem Constructor Workshop Implementation: PID Control ‚Ä¢ Commands control Arm with voltage ‚Ä¢ No position feedback control ‚Ä¢ Imprecise, inconsistent movement ‚Ä¢ No automatic target reaching ‚Ä¢ Manual voltage adjustment needed ‚Ä¢ PID position control with PositionVoltage ‚Ä¢ Automatic target position reaching ‚Ä¢ Precise, repeatable movements ‚Ä¢ Feedforward compensation for gravity ‚Ä¢ Tolerance checking for Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 3-PID Arm.java PID Implementation ‚Ä¢ <strong>PositionVoltage:</strong> Replaces VoltageOut for closed-loop control ‚Ä¢ <strong>Slot0 Config:</strong> PID and feedforward gains configuration ‚Ä¢ <strong>Target Setting:</strong> setTargetPosition() method for precise control Gain Values Used ‚Ä¢ <strong>kP = 24.0:</strong> Strong proportional response ‚Ä¢ <strong>kD = 0.1:</strong> Small derivative for damping ‚Ä¢ <strong>kS = 0.25:</strong> Static friction compensation ‚Ä¢ <strong>kG = 0.12:</strong> Gravity feedforward for Arm PID gives us precise position control! In the next section, we ‚Ä¢ Commands control Flywheel with voltage ‚Ä¢ No velocity feedback control ‚Ä¢ Inconsistent speed control ‚Ä¢ No automatic velocity targeting ‚Ä¢ PID velocity control with VelocityVoltage ‚Ä¢ Automatic target velocity reaching ‚Ä¢ Consistent, repeatable speeds ‚Ä¢ Feedforward compensation for friction ‚Ä¢ Velocity tolerance checking for src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>VelocityVoltage:</strong> Replaces VoltageOut for closed-loop velocity control ‚Ä¢ <strong>Slot0 Config:</strong> PID and feedforward gains configuration for velocity ‚Ä¢ <strong>Target Setting:</strong> setTargetVelocity() method for precise speed control ‚Ä¢ <strong>kP:</strong> Proportional response for velocity error ‚Ä¢ <strong>kI:</strong> Integral gain to eliminate steady-state velocity error ‚Ä¢ <strong>kS:</strong> Static friction compensation for startup ‚Ä¢ <strong>kV:</strong> Velocity feedforward for smooth operation PID gives us precise velocity control! In the next section, we üìù Knowledge Check What does the (Proportional) term in PID control do? It accumulates error over time It applies output proportional to the current error It predicts future error trends It eliminates steady-state error The Proportional term applies output proportional to the current error (Target - Current). Larger error results in stronger correction, providing immediate response to changes. What is the primary purpose of the (Integral) term in PID control? To provide immediate response to error To reduce overshoot and oscillation To eliminate steady-state error by accumulating past errors To predict future system behavior The Integral term accumulates error over time, helping eliminate steady-state error where the system settles close to but not exactly at the target. However, it can cause and is often left at zero in FRC applications. (Derivative) term help prevent in PID control? Steady-state error Slow response time Overshoot and oscillation Motor overheating The Derivative term responds to the rate of change of error, helping reduce overshoot by dampening the response as the system approaches the target. Which feedforward gain is used to overcome static friction? kS (Static) is a constant output applied to overcome static friction and get the mechanism moving. It Which feedforward gain is specifically used for arms and elevators to compensate for gravitational forces? kG (Gravity) compensates for gravitational forces acting on the mechanism. This is essential for arms and elevators that fight gravity at different positions. What does PID control use to automatically adjust motor output? Time-based scheduling Sensor feedback to measure error Random voltage adjustments Manual driver input only PID control uses sensor feedback (encoders, velocity measurements) to calculate the error between target and current position/velocity, then automatically adjusts motor output to minimize that error.',
    url: "/pid-control",
    category: "Workshop 1",
    tags: [
      "pid-control",
      "pid",
      "frc",
      "control",
      "motor",
      "ctre",
      "java",
      "subsystem",
      "workshop",
      "robot",
    ],
  },
  {
    id: "prerequisites",
    title: "Prerequisites",
    description:
      "Required software and hardware setup before starting the workshop.",
    content:
      "üìã Software Requirements WPILib Game Tools Install WPILib VS Code and National Instruments Game Tool (includes Driver Station and roboRIO imaging). Phoenix Tuner X Essential for configuring and tuning TalonFX and other CTRE hardware. Git Use Git for version control. Summarize changes clearly (e.g., 'Add drivetrain PID tuning logic'). PathPlanner Allows you to draw paths for your swerve drive to follow. Elastic Dashboard Drivers use a dashboard to easily view the robot and key items, such as selecting autonomous routines or viewing motor errors. Java Knowledge Ideally, some basic knowledge of Java coding (optional but recommended). Ready to Start? Make sure you have all the prerequisites installed before proceeding to the hardware setup section. Prerequisites /introduction Introduction /mechanism-cad Mechanism CAD grid gap-6 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-4 space-y-6 border-l-4 border-purple-200 dark:border-purple-900 pl-4 text-lg font-semibold text-slate-900 dark:text-slate-100 https://docs.wpilib.org/en/stable/docs/zero-to-robot/step-2/wpilib-setup.html text-purple-600 underline hover:no-underline dark:text-purple-400 _blank noopener noreferrer https://www.ni.com/en/support/downloads/drivers/download.frc-game-tools.html#553883 text-slate-600 dark:text-slate-300 mt-2 border-l-4 border-blue-200 dark:border-blue-900 pl-4 https://apps.microsoft.com/detail/9NVV4PWDW27Z text-blue-600 underline hover:no-underline dark:text-blue-400 border-l-4 border-green-200 dark:border-green-900 pl-4 https://git-scm.com/downloads text-green-600 underline hover:no-underline dark:text-green-400 border-l-4 border-orange-200 dark:border-orange-900 pl-4 https://github.com/mjansen4857/pathplanner/releases text-orange-600 underline hover:no-underline dark:text-orange-400 border-l-4 border-red-200 dark:border-red-900 pl-4 https://github.com/Gold872/elastic-dashboard text-red-600 underline hover:no-underline dark:text-red-400 border-l-4 border-yellow-200 dark:border-yellow-900 pl-4 https://www.codecademy.com/learn/learn-java text-yellow-600 underline hover:no-underline dark:text-yellow-400 bg-primary-50 dark:bg-primary-950/30 border border-primary-200 dark:border-primary-900 rounded-lg p-6 mb-8 text-lg font-semibold text-primary-700 dark:text-primary-300 mb-2 text-primary-800 dark:text-primary-300",
    url: "/prerequisites",
    category: "Getting Started",
    tags: [
      "prerequisites",
      "ctre",
      "hardware",
      "control",
      "pid",
      "robot",
      "motor",
      "java",
      "frc",
    ],
  },
  {
    id: "project-setup",
    title: "Project Setup",
    description:
      "Creating a new WPILib project and configuring it for CTRE hardware integration.",
    content:
      'Creating a New WPILib Project Follow these step-by-step instructions to create a new FRC robot project using the Command Robot Skeleton (Advanced) template. Open VSCode Launch Visual Studio Code with the WPILib extension installed. Select the WPILib Logo in Top Right Corner Click on the WPILib logo/icon in the top right corner of VSCode. Select "Create a New Project" From the WPILib menu, choose the "Create a new project" option. Select "Select a project type (Example or Template)" Command Robot Skeleton (Advanced) Base folder select "Downloads" OneDrive locations are not supported and will cause project creation to fail. Project Name "Workshop" Enter "Workshop" as your project name. Team Number Enter your FRC team number. This is required for deploying code to your robot. Check "Enable Desktop Support" This allows you to test your robot code on your computer without a robot. Generate Project Click "Generate Project" and then open the new project when prompted. After creating your project, you\'ll learn about the Command-Based Framework in the next section. Your project will be ready for implementing subsystems and commands! Project Setup /hardware Hardware Setup /command-framework Command-Based Framework Project Setup - Launching Your Codebase Step-by-step guide to generating a new WPILib project using the Command framework template. Starting with the right template ensures organized commands and subsystems. bg-slate-50 dark:bg-slate-900 rounded-lg p-8 shadow-lg border border-slate-200 dark:border-slate-800 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-6 text-slate-600 dark:text-slate-300 mb-6 space-y-4 flex items-start space-x-3 bg-primary-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm font-bold font-medium text-slate-600 dark:text-slate-300 text-sm warning ‚ö†Ô∏è Warning mt-2 https://www.youtube.com/embed/Y8ExsyaCC34 Project Setup Tutorial accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full h-full aspect-video rounded-lg tip üí° Next Step mt-4 Project Setup Quiz Which WPILib project template should you use for this workshop? Blank Project Timed Robot Romi Robot The Command Robot Skeleton (Advanced) template provides the proper structure for command-based programming with organized subsystems and commands. Why should you avoid using OneDrive locations for your WPILib project? OneDrive makes the project run slower OneDrive locations are not supported and will cause project creation to fail OneDrive deletes Java files automatically OneDrive doesn OneDrive locations are not supported by WPILib and will cause project creation to fail. Always use a local directory like Downloads or Documents. What is the purpose of enabling when creating your project? It makes the code run faster on the robot It allows you to test your robot code on your computer without a robot It enables wireless deployment to the robot It automatically generates all your robot code Desktop Support allows you to run and test your robot code on your computer without needing physical robot hardware, which is essential for development and testing. What should you name your project for this workshop? MyRobot FRC2024 Workshop CommandRobot The workshop instructions specify naming your project for consistency throughout the tutorial.',
    url: "/project-setup",
    category: "Workshop 1",
    tags: [
      "project-setup",
      "frc",
      "robot",
      "command",
      "workshop",
      "hardware",
      "java",
    ],
  },
  {
    id: "running-program",
    title: "Running Program",
    description:
      "Deploying and running robot code with hardware simulation and testing.",
    content:
      'Before running Hardware Simulation code, you must OFF the "CANivore USB" setting in TunerX. This prevents conflicts between the simulation environment and physical hardware communication. Open TunerX ‚Üí Go to CANivore settings ‚Üí Disable "CANivore USB" Hardware Simulation Setup Running Program /triggers Triggers /mechanism-setup Mechanism Setup Running Program - Hardware Simulation Testing WPILib provides a powerful tool called Hardware Simulation. This allows you to run your code in the simulator, while also running motors that are connected to the CANivore. Using a CANivore also allows you to build robot applications that run directly on Windows or Linux machines. Hardware simulation eliminates the need to use a roboRIO for testing, while still allowing you to test your code on hardware. warning w-6 h-6 none currentColor 0 0 24 24 round M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z Important: CANivore USB Setting mb-3 Steps mt-3 flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 https://www.youtube.com/embed/xsR7m6ToUFE Hardware Simulation accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture w-full h-full aspect-video rounded-lg üìù Knowledge Check What is the primary benefit of Hardware Simulation in WPILib? It makes code run faster than on a roboRIO It allows testing code with physical hardware without using a roboRIO It automatically fixes bugs in your code It provides better PID tuning than on real hardware Hardware Simulation allows you to run your code in the simulator while controlling real motors connected to the CANivore, eliminating the need for a roboRIO during testing. What setting must be turned OFF in TunerX before running Hardware Simulation code? Motor Control CANivore USB Simulation Mode Hardware Detection The setting must be turned OFF in TunerX to prevent conflicts between the simulation environment and physical hardware communication. What type of device enables Hardware Simulation with physical motors? roboRIO 2.0 Power Distribution Hub CANivore Radio The CANivore enables Hardware Simulation by allowing robot applications to run directly on Windows or Linux machines while controlling physical CAN devices. Which platforms can run Hardware Simulation with a CANivore? Only Windows Only Linux Windows and Linux Windows, Linux, and macOS Hardware Simulation with CANivore can run on both Windows and Linux machines, allowing for flexible development environments without a roboRIO.',
    url: "/running-program",
    category: "Workshop 1",
    tags: ["running-program", "hardware", "robot", "pid", "motor", "control"],
  },
  {
    id: "search",
    title: "search",
    description: "",
    content:
      "Search Results Loading search... max-w-4xl mx-auto mb-8 text-3xl font-bold text-slate-900 dark:text-slate-100 mb-4 flex items-center justify-center py-12 animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600 ml-2 text-slate-600 dark:text-slate-300",
    url: "/search",
    category: "General",
    tags: ["search"],
  },
  {
    id: "state-based",
    title: "State-Based Control",
    description:
      "Organizing subsystem behavior into discrete states for better code structure and maintainability.",
    content:
      'Understanding State-Based Architecture üèóÔ∏è State Pattern Benefits State-based control provides structure and predictability to subsystem behavior: Encapsulation: Maintainability: Readability: ‚öôÔ∏è State Components State Enum Defines all possible subsystem states with targets Current State Tracks which state the subsystem is currently in setState() Method Changes state and applies the new configuration State-Based Implementation in Code ArmState Enum: Defines LOW, HIGH, and BACKWARD states", "‚Ä¢ Encapsulated Targets: Each state contains its target position", "‚Ä¢ State-Specific Tolerances: Different tolerance for each position", "‚Ä¢ Current State Tracking: Always know which state the arm is in", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ setState() Method: Simple way to change arm configuration", "‚Ä¢ atState() Check: Easy validation using state-specific tolerance", "‚Ä¢ Semantic Names: Code clearly shows intent (HIGH vs 0.25 rotations)", "‚Ä¢ Extensible Design: FlywheelState Enum: Defines IDLE, SHOOTING, and INTAKE states", "‚Ä¢ Each state contains its target velocity", "‚Ä¢ Different tolerance for each mode", "‚Ä¢ Always know flywheel operating mode", ], rightTitle: "Enhanced Features", rightItems: [ "‚Ä¢ Simple way to change flywheel mode", "‚Ä¢ Code clearly shows intent (SHOOTING vs 3000 RPM)", "‚Ä¢ Manual Control Issues: Hard-coded values scattered everywhere Difficult to maintain and modify No clear organization of configurations Prone to inconsistencies and bugs Hard to understand code intent State-Based Benefits: Centralized configuration management Easy to add and modify states Clear, semantic code that shows intent Consistent tolerance and target handling Scales well with complex behaviors üè∑Ô∏è State Naming Guidelines Use Descriptive Names: HIGH STATE_1 SHOOTING FAST STARTING_POSITION STATE_2 Group Related States: Arm: LOW, HIGH, MIDDLE, BACKWARD Flywheel: STARTING_POSITION, MID_FIELD, FULL_FIELD Elevator: INTAKE, HAND_OFF, LEVEL_4 üìã State Organization Tips Include All Necessary Data: Target position/velocity State-specific tolerance Optional: timing constraints Optional: safety limits Design for Extensibility: Start with basic states, add complexity later Use constructor parameters for flexibility Consider state transitions and validation Plan for debugging and telemetry üéØ Why This Approach Works: State-based control provides a clean separation between configuration (what the states are) and behavior (how to reach them). This makes code easier to understand, test, and maintain as your robot becomes more complex. State-Based Control /vision-shooting Dynamic Flywheel Home State-Based Control - Structured Subsystem Management State-based control organizes subsystem behavior into discrete, well-defined states. Each state encapsulates target positions, tolerances, and specific configurations, making robot code more organized and maintainable. Instead of manually setting positions and tolerances everywhere, define states that encapsulate all the information needed for each subsystem configuration. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-2 gap-6 bg-[var(--muted)] rounded-lg p-6 border-l-4 border-[var(--border)] text-xl font-bold text-[var(--foreground)] mb-4 text-[var(--foreground)] mb-4 text-sm space-y-2 bg-slate-50 dark:bg-slate-900 p-3 rounded text-[var(--foreground)] text-[var(--muted-foreground)] text-sm bg-[var(--muted)] rounded-lg p-6 border-l-4 border-purple-500 space-y-3 font-bold text-[var(--foreground)] üîß State-Based Configuration Example java State Enum and Implementation Workshop Implementation: State-Based Control ‚Ä¢ Manual position and tolerance management ‚Ä¢ Hard-coded values scattered throughout code ‚Ä¢ Difficult to add new arm positions ‚Ä¢ No clear organization of arm configurations ‚Ä¢ Tolerance values repeated in multiple places ‚Ä¢ Well-defined states: LOW, HIGH, BACKWARD ‚Ä¢ Each state encapsulates target position and tolerance ‚Ä¢ Easy to add new states by extending the enum ‚Ä¢ Clear, readable code with semantic state names ‚Ä¢ Centralized configuration management Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Arm.java 6-StateBased Arm.java State-Based Architecture ‚Ä¢ <strong>ArmState Enum:</strong> Defines LOW, HIGH, and BACKWARD states ‚Ä¢ <strong>Encapsulated Targets:</strong> Each state contains its target position ‚Ä¢ <strong>State-Specific Tolerances:</strong> Different tolerance for each position ‚Ä¢ <strong>Current State Tracking:</strong> Always know which state the arm is in Enhanced Features ‚Ä¢ <strong>setState() Method:</strong> Simple way to change arm configuration ‚Ä¢ <strong>atState() Check:</strong> Easy validation using state-specific tolerance ‚Ä¢ <strong>Semantic Names:</strong> Code clearly shows intent (HIGH vs 0.25 rotations) ‚Ä¢ <strong>Extensible Design:</strong> Add new states without changing existing code State-based control makes our arm subsystem much more organized and maintainable! This pattern scales well as we add more complex behaviors. ‚Ä¢ Manual velocity and tolerance management ‚Ä¢ Hard-coded RPM values throughout the code ‚Ä¢ Difficult to add new shooting modes ‚Ä¢ No clear organization of flywheel configurations ‚Ä¢ Tolerance values scattered in multiple places ‚Ä¢ Well-defined states: IDLE, SHOOTING, INTAKE ‚Ä¢ Each state encapsulates target velocity and tolerance ‚Ä¢ Easy to add new shooting modes by extending enum ‚Ä¢ Centralized flywheel configuration management src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java ‚Ä¢ <strong>FlywheelState Enum:</strong> Defines IDLE, SHOOTING, and INTAKE states ‚Ä¢ <strong>Encapsulated Targets:</strong> Each state contains its target velocity ‚Ä¢ <strong>State-Specific Tolerances:</strong> Different tolerance for each mode ‚Ä¢ <strong>Current State Tracking:</strong> Always know flywheel operating mode ‚Ä¢ <strong>setState() Method:</strong> Simple way to change flywheel mode ‚Ä¢ <strong>Semantic Names:</strong> Code clearly shows intent (SHOOTING vs 3000 RPM) ‚Ä¢ <strong>Extensible Design:</strong> Add new modes without changing existing code State-based control makes our flywheel subsystem much more organized and maintainable! This pattern is essential for complex shooting systems. ‚öñÔ∏è State-Based vs Manual Control warning font-semibold text-[var(--foreground)] mb-2 text-sm text-[var(--foreground)] space-y-1 list-disc list-inside üí° State Design Best Practices info bg-blue-50 dark:bg-blue-950 p-4 rounded-lg border border-blue-200 dark:border-blue-800 font-semibold text-blue-800 dark:text-blue-200 mb-3 flex items-center space-y-4 text-sm text-[var(--foreground)] space-y-2 list-disc list-inside bg-slate-50 dark:bg-slate-800 px-1 rounded bg-green-50 dark:bg-green-950 p-4 rounded-lg border border-green-200 dark:border-green-800 font-semibold text-green-800 dark:text-green-200 mb-3 flex items-center bg-[var(--muted)] p-4 rounded mt-4 border-l-4 border-[var(--border)] text-[var(--foreground)] text-sm üìù Knowledge Check What is the primary benefit of using state-based control? It makes motors run faster It organizes subsystem behavior into well-defined, maintainable states It eliminates the need for PID control It automatically tunes feedforward gains State-based control encapsulates target positions, tolerances, and configurations into discrete states, making robot code more organized, maintainable, and easier to understand. What does each state in a state-based system contain? Only the target position Only the tolerance value Target position, tolerance, and configuration data Only the motor ID and voltage Each state encapsulates all the information needed for that configuration: target position/velocity, state-specific tolerance, and any other relevant settings. How does state-based control improve code readability? It uses shorter variable names It reduces the number of lines of code It uses semantic names that clearly show intent (e.g., HIGH vs 0.25 rotations) It eliminates all comments from code State-based control uses descriptive, semantic names (like HIGH, LOW, SHOOTING) instead of hard-coded values, making the code What is the purpose of the setState() method in a state-based subsystem? To turn the motor on or off To change to a new state and apply its configuration To check if the subsystem is at the target To reset all state variables to zero The setState() method changes the current state of the subsystem and automatically applies the new state Which of the following is a state-based control best practice? Use generic names like STATE_1, STATE_2, STATE_3 Store all values in separate variables throughout the code Use descriptive state names that indicate purpose (e.g., INTAKE, SHOOTING, STOWED) Avoid using enums for states Best practice is to use descriptive state names that clearly indicate the purpose and configuration of each state, making code self-documenting and easier to maintain.',
    url: "/state-based",
    category: "Advanced",
    tags: [
      "state-based",
      "control",
      "subsystem",
      "robot",
      "java",
      "workshop",
      "frc",
      "pid",
      "motor",
    ],
  },
  {
    id: "swerve-calibration",
    title: "swerve-calibration",
    description: "",
    content:
      "Accurate calibration ensures your robot knows exactly where it is on the field, enabling precise autonomous movement and vision integration. Below is a graphic showing the order we follow when setting up a robot. Motor Calibration Start by tuning your drive and turning motors to ensure they respond correctly to commands and maintain accurate position tracking. Tune Drive and Turning Motors Configure motor PID values, velocity/acceleration limits, and ensure proper sensor feedback. Key Calibration Steps: Make sure to read and follow Tuner X instructions carefully Verify your robot drives correct direction Tune turning motor first then move onto drive motors Stator Current Highly Recommended: Glue your drive encoders in place to prevent them from shifting during impacts or aggressive movements. Even small encoder shifts can cause significant odometry drift. Effective Wheel Radius The effective wheel radius accounts for compression, tread wear, and carpet interaction. This value is critical for accurate odometry. Wheel Radius Test Procedure Follow this systematic procedure to determine your robot's effective wheel radius. Drive Forward at Low Acceleration Command the robot to drive straight forward for a fixed distance (e.g., 3 meters) at low acceleration to minimize wheel slip. Record Sensor-Reported Distance Log the distance traveled as calculated from encoder readings. This will differ from the actual distance due to wheel compression and slip. Measure True Distance Traveled Use a tape measure to determine the actual distance the robot moved. Measure from the starting position to the final position. Calculate Rolling Radius effectiveRadius = (actualDistance / sensorDistance) * currentRadius Perform this test on the same surface you'll compete on (carpet vs. tile affects compression) Run multiple trials and average the results for better accuracy Re-calibrate if you change wheels or tread Camera Setup & Calibration Accurate camera calibration ensures vision measurements integrate correctly with your odometry, providing reliable pose estimates. Limelight Camera Configuration Set up your Limelight camera with proper positioning, focus, and calibration. Camera Setup Checklist: 1. Camera Position Configuration Enter the camera's position relative to the robot center in the Limelight web interface. Accurate position values are critical for pose estimation. 2. Camera Calibration Use a Limelight calibration board to calibrate your camera. This corrects for lens distortion and improves pose accuracy, especially at the edges of the field of view. 3. Lens Focus & Security glue the lens in place to prevent it from shifting due to vibrations. Refer to the official Limelight AprilTag documentation for detailed camera calibration instructions and best practices: PathPlanner PID Tuning PathPlanner uses PID controllers to follow autonomous paths accurately. Proper tuning ensures your robot tracks paths smoothly without oscillation or lag. PathPlanner Configuration - Do in the GUI Robot Config should be as accurate as possible to your robot, and many configs are available online. However, to significantly help path tracking, configure the App Settings, which contain the MotionMagic configurations for PathPlanner. App Setting: Max Velocity: Set to 80-90% of your robot's maximum speed. This provides headroom for PID corrections. App Setting: Max Acceleration: Conservative values (2-3 m/s¬≤) prevent wheel slip. Increase gradually while testing. App Setting: Max Angular Velocity: Limit rotational speed to prevent modules from fighting each other. App Setting: Max Angular Acceleration: Limit rotational acceleration to prevent robot from rotating too quickly. Tune PathPlanner PID values like normal. However be aware that due to loop times these cannot be tuned as aggressively. What's Next? Up Next: Vision-Based Shooting With your odometry fully calibrated, you're ready to apply vision data for automated targeting and distance-based shooting calculations. You'll learn how to use vision feedback to calculate shooter angles and velocities dynamically. Odometry Calibration /vision-implementation Implementing Vision /vision-shooting Dynamic Flywheel Calibrating Your Robot Proper calibration is the foundation of accurate autonomous performance. This includes tuning motor values, finding the effective wheel radius, configuring camera positions, and tuning PID controllers for path following. Calibration transforms theoretical parameters into real-world accuracy. text-slate-600 dark:text-slate-300 text-center -mt-4 /images/odometry-setup/Robot Flowchart.png Odometry calibration setup showing measurement procedure flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 flex items-start gap-4 mb-4 bg-primary-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 w-5 h-5 text-xl font-bold text-slate-900 dark:text-slate-100 mb-2 text-slate-600 dark:text-slate-300 mb-4 space-y-4 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 font-semibold text-slate-900 dark:text-slate-100 mb-2 list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 https://v6.docs.ctr-electronics.com/en/stable/docs/hardware-reference/talonfx/improving-performance-with-current-limits.html#preventing-wheel-slip _blank noopener noreferrer text-primary-600 dark:text-primary-400 hover:underline tip üí° Encoder Security bg-green-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 bg-primary-50 dark:bg-primary-950/30 p-6 rounded-lg border border-primary-200 dark:border-primary-800 flex gap-4 bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-semibold text-slate-900 dark:text-slate-100 text-sm text-slate-600 dark:text-slate-300 mt-1 bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-primary-800 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-slate-100 dark:bg-slate-800 px-2 py-1 rounded warning ‚ö†Ô∏è Test Conditions Matter list-disc list-inside space-y-1 text-sm bg-orange-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 font-semibold text-slate-900 dark:text-slate-100 mb-3 space-y-3 text-sm font-semibold text-slate-900 dark:text-slate-100 info üìç Limelight Documentation mb-2 https://docs.limelightvision.io/docs/docs-limelight/getting-started/performing-charuco-camera-calibration Limelight Calibration Guide text-xl font-bold text-slate-900 dark:text-slate-100 mb-4 üéØ Tuning Strategy üìù Knowledge Check What is the first step in the odometry calibration process? Measure wheel diameter with calipers Tune drive and turning motors Calibrate the camera Create PathPlanner paths The calibration flowchart shows that tuning drive and turning motors is the first step. This ensures motors respond correctly to commands and maintain accurate position tracking before proceeding with other calibrations. Why is effective wheel radius different from the nominal wheel diameter? Manufacturing tolerances in the wheels Wheel compression, tread wear, and carpet interaction Temperature changes during operation Motor gear ratios affect the measurement The effective wheel radius accounts for real-world factors like wheel compression under robot weight, tread wear over time, and how the wheel interacts with carpet surfaces. These factors cause the actual distance traveled to differ from theoretical calculations. What should you do after properly focusing a Limelight camera lens? Leave it as-is for future adjustments Glue the lens in place to prevent shifting Cover it with tape for protection Record the focus setting in your code Once the Limelight lens is properly focused for your AprilTag detection distance, you should glue the lens in place to prevent it from shifting due to robot vibrations during competition, which would ruin your calibration. How do you calculate the effective wheel radius from a drive test? Divide sensor distance by actual distance Multiply (actual distance / sensor distance) by current radius Add the difference to the nominal radius Average multiple wheel diameter measurements The formula is: effectiveRadius = (actualDistance / sensorDistance) * currentRadius. This ratio corrects your theoretical radius based on how far the robot actually moved compared to what the sensors reported. Why is it recommended to glue drive encoders in place? To protect them from water damage To prevent them from shifting during impacts, which causes odometry drift To improve their accuracy To reduce electrical noise Even small encoder shifts caused by impacts or aggressive movements can cause significant odometry drift. Gluing encoders in place ensures they maintain their position and continue to provide accurate measurements throughout competition. bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/swerve-calibration",
    category: "General",
    tags: [
      "swerve-calibration",
      "robot",
      "motor",
      "pid",
      "command",
      "hardware",
    ],
  },
  {
    id: "swerve-drive-project",
    title: "Creating a Swerve Drive Project",
    description:
      "Advanced workshop on implementing swerve drive systems for omnidirectional robot movement.",
    content:
      "Swerve Drive Prerequisites Holonomic motion and swerve drive concepts Module anatomy (drive motor, azimuth motor, CANcoder) Coordinate systems (robot-centric vs field-centric) Creating a Swerve Project with Phoenix Tuner X CTRE provides a comprehensive swerve drive project generator in Phoenix Tuner X that creates a complete, competition-ready swerve drivetrain implementation. This is the recommended starting point for all swerve projects. What the Generator Creates: Complete CommandSwerveDrivetrain subsystem Tuner constants for all swerve parameters Module configurations and CAN IDs Field-centric and robot-centric drive commands Simulation support for testing without hardware PathPlanner integration for autonomous Required Information: CAN IDs for all drive motors, steer motors, encoders CANivore name (if using CANivore) Wheel diameter and gear ratios Module positions (wheelbase and trackwidth) Step-by-Step Setup Process Open Phoenix Tuner X Launch Phoenix Tuner X and connect to your robot or CANivore. Ensure all swerve motors and encoders are visible and have unique CAN IDs. Navigate to Swerve Project Generator Click on Mechanisms in the left sidebar. This will open the configuration wizard. Configure Robot Parameters Enter your robot's physical parameters: Wheelbase: Front-to-back distance between modules (meters) Trackwidth: Side-to-side distance between modules (meters) Wheel Diameter: Diameter of drive wheels (inches) Drive Gear Ratio: Motor rotations per wheel rotation Follow the Steps to Generate and Export Click New Project and follow the steps in Tuner X to set up and test your swerve drivetrain. Once you finish, click Generate Project and you'll have a completed project fully ready to deploy and drive your robot. What's Next? Up Next: PathPlanner Now that your swerve project is generated, the next step is autonomous path following with PathPlanner. Creating a Swerve Drive Project /swerve-prerequisites /pathplanner Adding PathPlanner Using Phoenix Tuner X to Generate Swerve Code With the swerve drive fundamentals covered, we s Phoenix Tuner X. This powerful tool generates production-ready swerve code, handling all the complexity of kinematics, odometry, and control. Phoenix Tuner X generates a complete, competition-ready swerve drivetrain with one configuration wizard. info Prerequisites Complete? mb-2 text-primary-600 underline hover:no-underline hover:text-primary-800 dark:text-primary-400 dark:hover:text-primary-300 font-medium list-disc list-inside space-y-1 text-sm text-slate-600 dark:text-slate-300 flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 üöÄ CTRE Swerve Project Generator mb-4 grid md:grid-cols-2 gap-4 font-semibold text-slate-900 dark:text-slate-100 mb-2 space-y-6 text-2xl font-bold text-slate-900 dark:text-slate-100 space-y-4 flex items-start space-x-4 bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 flex-1 text-slate-600 dark:text-slate-300 text-slate-600 dark:text-slate-300 mb-3 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 space-y-2 text-sm text-slate-600 dark:text-slate-300 https://v6.docs.ctr-electronics.com/en/latest/docs/tuner/tuner-swerve/index.html CTRE Swerve Project Generator Documentation w-5 h-5 üìù Knowledge Check What tool does CTRE provide to generate a complete swerve drivetrain project? WPILib Project Creator Phoenix Tuner X Visual Studio Code Extension PathPlanner GUI Phoenix Tuner X includes a comprehensive swerve project generator that creates a complete, competition-ready swerve drivetrain implementation with CommandSwerveDrivetrain, tuner constants, module configurations, and simulation support. What information is required when configuring your robot in Phoenix Tuner X? Only motor CAN IDs Only wheel diameter CAN IDs, wheelbase, trackwidth, wheel diameter, and gear ratios Just the CANivore name The Phoenix Tuner X swerve generator requires comprehensive robot parameters including all CAN IDs (drive motors, steer motors, encoders), physical dimensions (wheelbase and trackwidth), wheel diameter, drive gear ratio, and CANivore name if applicable. What does the Phoenix Tuner X swerve generator automatically create? Only motor configurations Complete CommandSwerveDrivetrain subsystem, tuner constants, module configs, field-centric drive commands, simulation support, and PathPlanner integration Only the subsystem code Just the CAN ID mappings The swerve generator creates a comprehensive package including the CommandSwerveDrivetrain subsystem, TunerConstants with all parameters, module configurations, field-centric and robot-centric drive commands, simulation support for testing, and PathPlanner integration for autonomous. Where do you access the swerve project generator in Phoenix Tuner X? File > New Project Tools > Swerve Generator Mechanisms in the left sidebar Settings > Robot Configuration The swerve project generator is accessed through the Mechanisms option in Phoenix Tuner X What is the wheelbase measurement used in swerve configuration? Side-to-side distance between modules Front-to-back distance between modules Diagonal distance between opposite modules Distance from robot center to wheel Wheelbase is the front-to-back distance between swerve modules (measured in meters). This is different from trackwidth, which is the side-to-side distance. Both measurements are critical for accurate kinematics calculations. bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4 text-slate-600 dark:text-slate-300 mb-4",
    url: "/swerve-drive-project",
    category: "Workshop 2",
    tags: [
      "swerve-drive-project",
      "motor",
      "robot",
      "ctre",
      "subsystem",
      "hardware",
      "control",
    ],
  },
  {
    id: "swerve-prerequisites",
    title: "Swerve Drive Prerequisites",
    description:
      "Understanding swerve drive fundamentals: holonomic motion, coordinate systems, and module anatomy.",
    content:
      "Swerve Module Anatomy Each swerve module consists of three key components that work together to provide independent wheel control: Drive Motor Controls the wheel speed and provides forward/backward motion for the module. Typically a high-power motor like Kraken X60 or Falcon 500. Purpose: Translational velocity control Control: Velocity PID or voltage control Sensor: Integrated encoder for speed feedback Turning Motor Steers the module by rotating the wheel to the desired angle. Requires precise position control with absolute encoder feedback. Wheel direction control Position PID with Motion Magic Absolute encoder (CANcoder) for angle CANcoder Absolute position sensor that tracks the steering angle. Critical for module zeroing and maintaining accurate wheel orientation. Absolute angle measurement Type: WCP ThroughBore or CANcoder V2 Units: Rotations (0 to 1.0) Coordinate Systems &amp; Reference Frames Understanding coordinate systems is crucial for swerve drive control. You need to know whether movements are relative to the robot or the field. Robot-Centric (Robot Frame) All movements are relative to the robot's current orientation. Forward is always toward the front of the robot. Forward: Robot moves in the direction it's facing Strafe Right: Robot moves to its right side Use Case: Precise maneuvering, driver preference More intuitive for beginners Field-Centric (Field Frame) All movements are relative to the field. Forward is always away from your driver station, regardless of robot orientation. Robot moves away from driver station Robot moves right on the field Competition driving, intuitive control Requirement: Needs gyro for robot heading Field-centric control requires a gyroscope (IMU) to track the robot's heading. Without an accurate heading, the robot cannot determine which direction is \"forward\" relative to the field. Common gyros in FRC: Pigeon 2 (CTRE) - CAN-based, highly accurate NavX (Kauai Labs) - USB/SPI, popular choice ADIS16470 (Analog Devices) - SPI, WPILib support Swerve Kinematics &amp; Control Kinematics is the mathematical relationship between the desired robot motion (velocities in X, Y, and rotation) and the individual wheel states (speed and angle) needed to achieve that motion. üìê Forward Kinematics Converts individual wheel states into overall robot velocity. Used for odometry and determining where the robot is moving. Given: [FL, FR, BL, BR] module states Calculate: Robot velocity (Vx, Vy, omega) Example: If all modules point forward at the same speed, the robot is moving straight forward with no rotation. üìê Inverse Kinematics Converts desired robot velocity into individual wheel states. Used for teleop driving and autonomous path following. Given: Robot velocity (Vx, Vy, omega) Calculate: [FL, FR, BL, BR] module states To strafe right while rotating, inverse kinematics calculates the unique angle and speed for each module. The good news: CTRE's swerve implementation handles all kinematics calculations internally. You don't need to manually compute wheel states! The CommandSwerveDrivetrain class uses Phoenix 6's built-in kinematics to convert your desired chassis speeds (Vx, Vy, omega) into the appropriate module states automatically. Chassis speeds represent the desired velocity of the robot as a whole: Vx (Forward/Back) Linear velocity in the X direction. Positive = forward, Negative = backward. Units: meters per second. Vy (Left/Right) Linear velocity in the Y direction. Positive = left, Negative = right. Units: meters per second. Omega (Rotation) Angular velocity (rotation rate). Positive = counter-clockwise, Negative = clockwise. Units: radians per second. Odometry &amp; Pose Estimation Odometry is the process of tracking the robot's position and orientation on the field by integrating wheel movements over time. Accurate odometry is essential for autonomous navigation and field-aware control. üó∫Ô∏è Pose2d: Robot Position on the Field The robot's pose consists of three components: X Position Distance along the field length (left/right from your driver station perspective). Units: meters. Y Position Distance along the field width (forward/backward from your driver station). Units: meters. Rotation Robot heading (which direction the robot is facing). Represented as Rotation2d. 0¬∞ = field forward. The field coordinate system origin (0, 0) is at the corner of the field from your alliance's perspective. X increases to the right, Y increases forward, and rotation is counter-clockwise positive. How Odometry Works üìä Wheel Odometry Primary odometry source using encoder readings from swerve modules. Inputs: Module positions (distance traveled + angle) Process: Forward kinematics converts module deltas to robot motion Integration: Accumulates motion over time to track pose Accuracy: Drifts over time due to wheel slip and measurement errors üì∏ Vision Odometry Secondary odometry source using camera and AprilTag vision targets. Detected AprilTags with known field positions Camera calculates robot pose from tag positions Fused with wheel odometry for drift correction More accurate but only works when tags are visible CTRE's includes built-in pose estimation that fuses wheel odometry with vision measurements using a Kalman filter approach. This provides more accurate position tracking than wheel odometry alone, automatically correcting for drift when vision targets are visible. What's Next? Ready for Implementation You now understand the fundamental concepts needed for swerve drive: Holonomic motion and independent module control Module anatomy: drive motor, azimuth motor, CANcoder Coordinate systems: robot-centric vs field-centric Gyro requirements for field-centric control Critical safety practices and zeroing procedures Swerve kinematics and control Odometry Pose estimation Next, you'll learn how to use Phoenix Tuner X to generate a complete swerve project and bring up your drivetrain. Swerve Drive Prerequisites /motion-magic Motion Magic /swerve-drive-project Creating a Swerve Drive Project Understanding Swerve Drive Fundamentals Before diving into swerve drive implementation, it Master the fundamentals of swerve drive: holonomic motion, coordinate systems, module anatomy, and field-centric control. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 grid md:grid-cols-1 lg:grid-cols-3 gap-8 bg-primary-100 dark:bg-primary-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-primary-900 dark:text-primary-300 text-slate-600 dark:text-slate-300 mb-4 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 text-sm text-slate-600 dark:text-slate-300 bg-green-100 dark:bg-green-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-green-900 dark:text-green-300 bg-orange-100 dark:bg-orange-900/20 p-4 rounded-lg mb-4 text-xl font-bold text-orange-900 dark:text-orange-300 grid md:grid-cols-2 gap-8 text-xl font-bold text-blue-900 dark:text-blue-300 mb-4 space-y-2 text-sm text-slate-600 dark:text-slate-300 text-xl font-bold text-green-900 dark:text-green-300 mb-4 info Gyro Requirement for Field-Centric mb-3 mb-2 list-disc list-inside space-y-1 text-xl font-bold text-primary-900 dark:text-primary-300 mb-4 text-xs text-slate-700 dark:text-slate-300 text-sm text-slate-600 dark:text-slate-300 mt-4 üîß CTRE Handles Kinematics Automatically üéÆ Understanding Chassis Speeds space-y-4 grid md:grid-cols-3 gap-4 bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg border-l-4 border-blue-500 font-bold text-blue-900 dark:text-blue-300 mb-2 bg-green-50 dark:bg-green-900/20 p-4 rounded-lg border-l-4 border-green-500 font-bold text-green-900 dark:text-green-300 mb-2 bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg border-l-4 border-purple-500 font-bold text-purple-900 dark:text-purple-300 mb-2 java Creating Chassis Speeds for Control bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-6 grid md:grid-cols-3 gap-4 mb-6 font-bold text-primary-600 dark:text-primary-400 mb-2 tip üí° Field Coordinate System space-y-6 text-2xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-2 gap-6 text-lg font-semibold text-slate-900 dark:text-slate-100 mb-3 list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 üîÄ Pose Estimation with Sensor Fusion üìù Odometry Code Examples Getting Current Robot Pose Robot X Robot Y Robot Heading grid md:grid-cols-2 gap-4 https://docs.wpilib.org/en/stable/docs/software/kinematics-and-odometry/swerve-drive-odometry.html WPILib Swerve Drive Odometry Documentation w-5 h-5 https://docs.wpilib.org/en/stable/docs/software/advanced-controls/state-space/state-space-pose-estimators.html WPILib Pose Estimators üìù Knowledge Check What are the three key components of a swerve module? Drive motor, turning motor, and gyroscope Drive motor, turning motor, and CANcoder Two drive motors and a CANcoder Drive motor, brake, and CANcoder Each swerve module consists of a drive motor (for speed), turning motor (for steering), and CANcoder (for absolute position sensing). What is the main difference between robot-centric and field-centric control? Robot-centric is faster than field-centric Robot-centric uses relative movement to the robot, field-centric uses movement relative to the field Field-centric doesn Robot-centric only works with tank drive Robot-centric control moves relative to the robot s front), while field-centric moves relative to the field (forward is always away from the driver station). What sensor is required for field-centric swerve drive control? Ultrasonic sensor Camera Gyroscope (IMU) Accelerometer only A gyroscope (IMU) is required for field-centric control to track the robot forward What does inverse kinematics calculate in swerve drive? Robot velocity from wheel states Individual wheel states from desired robot velocity Motor temperatures from current usage Battery voltage from power consumption Inverse kinematics converts desired robot velocity (Vx, Vy, omega) into the individual wheel speeds and angles needed to achieve that motion. What are the three components of chassis speeds in swerve drive? Left speed, right speed, rotation Forward speed, backward speed, turning speed Vx (forward/back), Vy (left/right), Omega (rotation) Motor speed, wheel speed, encoder speed Chassis speeds consist of Vx (linear velocity in X direction), Vy (linear velocity in Y direction), and Omega (angular velocity for rotation). What is the primary purpose of odometry in swerve drive? To control motor speeds To track the robot To communicate with other robots To measure battery voltage Odometry tracks the robot Which component provides absolute angle measurement for the steering system? Drive motor encoder Turning motor internal encoder Gyroscope The CANcoder provides absolute position sensing for the steering angle, which is critical for module zeroing and maintaining accurate wheel orientation. What does CTRE Only motor control Kinematics calculations and pose estimation Only sensor readings Only path planning CTRE bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4 text-slate-600 dark:text-slate-300 mt-4",
    url: "/swerve-prerequisites",
    category: "Workshop 2",
    tags: [
      "swerve-prerequisites",
      "control",
      "motor",
      "pid",
      "robot",
      "frc",
      "ctre",
      "java",
    ],
  },
  {
    id: "triggers",
    title: "Triggers",
    description:
      "Binding controller inputs to commands using triggers for responsive robot control.",
    content:
      "Trigger Implementation & Examples üéØ Trigger Examples - Binding Input to Commands controller.a() &nbsp;&nbsp;.onTrue(command); Run a command once when a button is pressed or condition becomes true. The command completes its full lifecycle (initialize, execute, end). &nbsp;&nbsp;.onFalse(command); Run a command once when a button is released or condition becomes false. Perfect for stopping motors or returning to safe positions. .onTrue(cmd1) .onFalse(cmd2); Chain onTrue() and onFalse() together to define different actions for press and release, giving you full control over button behavior. new Trigger( &nbsp;&nbsp;() => sensor.get()) &nbsp;&nbsp;.onTrue(cmd); Triggers can be created from any boolean condition - sensors, limit switches, or custom logic - not just controller buttons. üîÑ Before ‚Üí After: Implementation üìã Before ‚Ä¢ Empty RobotContainer constructor ‚Ä¢ No controller declared ‚Ä¢ No configureBindings() method ‚Ä¢ Commands exist but can't be triggered ‚úÖ After ‚Ä¢ CommandXboxController instantiated ‚Ä¢ configureBindings() method created ‚Ä¢ Button triggers bound to commands ‚Ä¢ Robot responds to controller input üéØ Final Implementation & GitHub Changes üöÄ Advanced Command Patterns ‚ÑπÔ∏è Advanced Topics - Beyond This Workshop This workshop uses simplified patterns ( runOnce() onTrue() onFalse() ) for easier learning. The examples below show advanced command patterns that are powerful for competition but not required for this workshop's scope. üí° Feel free to explore these after completing the workshop fundamentals! Extending WPILib Command For more complex commands, extend Command directly instead of using inline methods. See WPILib documentation ‚Üí Complex Command Groups Combine sequences and parallel actions to coordinate subsystems. Composition Strategies Use fluent helpers to assemble commands from smaller pieces. Common Pitfalls Always declare subsystem requirements to avoid unexpected conflicts. Advanced Triggers Create triggers from sensor conditions or button combinations. Real-World Scenario Combine patterns to build robust autonomous routines. Triggers /adding-commands Commands /running-program Running Program Triggers - Connecting User Input to Commands Triggers link user inputs (buttons, joysticks, sensors) to commands. They define when and how commands should run based on controller input or robot state. Use onTrue() to run commands when buttons are pressed, and onFalse() to run commands when buttons are released. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-xl font-bold text-primary-600 mb-4 cursor-pointer hover:text-primary-700 dark:hover:text-primary-300 mt-4 java RobotContainer.java - configureBindings() grid md:grid-cols-2 gap-6 mb-6 üéÆ onTrue() Trigger üîΩ onFalse() Trigger grid md:grid-cols-2 gap-6 üîÑ Chaining Triggers üéØ Sensor Triggers text-xl font-bold text-slate-900 dark:text-slate-100 mb-4 bg-red-50 dark:bg-red-950/20 rounded-lg p-4 border border-red-200 dark:border-red-800 text-lg font-bold text-red-800 dark:text-red-300 mb-3 space-y-2 text-red-700 dark:text-red-300 text-sm bg-green-50 dark:bg-green-950/20 rounded-lg p-4 border border-green-200 dark:border-green-800 text-lg font-bold text-green-800 dark:text-green-300 mb-3 space-y-2 text-green-700 dark:text-green-300 text-sm text-lg font-bold text-slate-900 dark:text-slate-100 mb-3 Hemlock5712/Workshop-Code src/main/java/frc/robot/RobotContainer.java 2-Commands RobotContainer.java mt-4 space-y-8 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6 flex items-start gap-3 w-6 h-6 text-blue-600 dark:text-blue-400 flex-shrink-0 mt-0.5 none currentColor 0 0 24 24 round M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z text-lg font-bold text-blue-800 dark:text-blue-300 mb-2 text-blue-700 dark:text-blue-300 mb-3 bg-blue-100 dark:bg-blue-900 px-1.5 py-0.5 rounded text-sm text-sm text-blue-600 dark:text-blue-400 text-xl font-bold text-[var(--foreground)] mb-2 text-slate-600 dark:text-slate-300 mb-4 https://docs.wpilib.org/en/stable/docs/software/commandbased/commands.html#simple-command-example _blank noopener noreferrer text-primary-600 hover:text-primary-700 dark:text-primary-400 dark:hover:text-primary-300 underline ml-1 üìù Knowledge Check What is the primary purpose of triggers in command-based programming? To configure motor speeds To link user inputs or sensor conditions to commands To manage subsystem hardware To log telemetry data What does the onTrue() trigger method do? Runs a command continuously while a button is held Runs a command once when a button is pressed or condition becomes true Stops a command when a button is released Toggles a command on and off with each press onTrue() runs a command once when a button is pressed or condition becomes true. The command completes its full lifecycle (initialize, execute, end). What does the onFalse() trigger method do? Disables a command permanently Runs a command once when a button is released or condition becomes false Prevents a command from running Runs a command while a button is not pressed onFalse() runs a command once when a button is released or condition becomes false. It What is the benefit of chaining onTrue() and onFalse() together? It makes the code run faster It defines different actions for button press and release It prevents commands from conflicting It automatically adds safety features Chaining onTrue() and onFalse() allows you to define different actions for press and release, giving you full control over button behavior (e.g., start motor on press, stop on release). Besides controller buttons, what else can be used to create triggers? Only Xbox controller buttons are supported Any boolean condition - sensors, limit switches, or custom logic Only joystick axes Only keyboard inputs Triggers can be created from any boolean condition using . This includes sensors, limit switches, or any custom logic that returns true/false.",
    url: "/triggers",
    category: "Workshop 1",
    tags: [
      "triggers",
      "command",
      "control",
      "robot",
      "workshop",
      "subsystem",
      "java",
      "frc",
      "motor",
      "hardware",
    ],
  },
  {
    id: "vision-implementation",
    title: "Implementing Vision",
    description:
      "Practical implementation of vision systems in robot code for target detection and tracking.",
    content:
      "Vision Implementation Strategy Implementing vision requires a systematic approach to ensure reliable pose estimation. Follow these steps to integrate Limelight vision data into your robot's odometry system while maintaining accuracy and trust. üöÄ Implementation Sequence LimelightHelpers Library First, import the Limelight helper library available on GitHub. It contains pre-built NetworkTables wrappers that provide clean access to vision data without manual NetworkTables subscriptions. Limelight Subsystem Next, create a new subsystem to pull values using the Limelight helper tool. In this subsystem there are three things we need in order to add them to our pose estimator: Pose, Timestamp, and Standard Deviation (how much we will trust the reading). Both pose and timestamp are provided by LimelightHelpers, however we need to create a formula for how much to trust vision. Utilizing CTRE Pose Estimator Once we have the three values above, we can pass them into the CTRE Pose Estimator. It has pre-programmed functions that accept these values. However, we need to pass this pose estimator to the vision subsystem to add measurements. RobotContainer Setup At this point we have the pose estimator in drivetrain and now can create a vision subsystem that takes in drivetrain to add values to it. Standard Deviation Tuning As mentioned, we need a formula for how much to trust the vision reading. For this, we will use a simple formula we have used for the past two years based on tag count and distance. This formula can be significantly improved with even some simple modifications (inside field boundaries, single tag filter ambiguity, and several other checks). Library First: LimelightHelpers abstracts NetworkTables complexity. Validation Layer: The Limelight subsystem filters bad measurements before they make it to your pose estimate Dynamic Trust: Standard deviations adjust based on measurement quality, preventing bad data from degrading odometry Reading Limelight Data Limelight publishes vision data to NetworkTables. The LimelightHelpers library (provided by Limelight on GitHub) provides a clean API for reading this data without direct NetworkTables access. RobotContainer includes the setup for vision integration, showing how the Limelight subsystem connects with the swerve drivetrain and command bindings. Workshop Code Implementation The Workshop-Code repository includes complete vision implementation on the 3-Limelight branch, demonstrating Limelight integration with swerve drive and odometry. The code examples above are all taken directly from this branch, showing real working implementations you can reference and adapt for your own robot. Vision Best Practices Validate vision data before using it Account for latency (automatically done) Use appropriate standard deviations Test different exposures (lower is better) Log vision data for debugging Don't Trust vision measurements blindly Ignore latency compensation Use vision as only odometry source Forget to tune camera settings Skip testing in match conditions Additional Resources What's Next? Up Next: Odometry Calibration With vision integrated, you'll learn how to calibrate your robot's odometry for maximum accuracy, including motor tuning, wheel radius calibration, camera setup, and PathPlanner PID tuning. Implementing Vision /vision-options Vision Options /swerve-calibration Odometry Calibration Integrating Vision into Robot Code Connecting vision systems to robot code involves reading NetworkTables data, integrating AprilTag measurements into odometry, and using vision feedback for control. This section demonstrates practical vision integration patterns. Vision data transforms autonomous accuracy and enables intelligent teleop assistance. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 text-slate-600 dark:text-slate-300 grid md:grid-cols-1 gap-6 text-xl font-bold text-[var(--foreground)] mb-4 space-y-4 flex items-center gap-4 p-4 bg-primary-50 dark:bg-primary-950/20 rounded-lg bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-700 dark:text-primary-300 text-primary-600 dark:text-primary-400 text-sm flex items-center gap-4 p-4 bg-primary-100 dark:bg-primary-900/30 rounded-lg bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-800 dark:text-primary-200 text-primary-700 dark:text-primary-300 text-sm flex items-center gap-4 p-4 bg-primary-200 dark:bg-primary-800/40 rounded-lg bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-900 dark:text-primary-100 text-primary-800 dark:text-primary-200 text-sm flex items-center gap-4 p-4 bg-primary-300 dark:bg-primary-700/50 rounded-lg bg-primary-800 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-primary-950 dark:text-white text-primary-900 dark:text-primary-100 text-sm flex items-center gap-4 p-4 bg-primary-400 dark:bg-primary-600/60 rounded-lg bg-primary-900 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-bold text-slate-900 dark:text-white text-slate-800 dark:text-slate-100 text-sm info Why This Approach? list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 LimelightHelpers.java LimelightVision/limelightlib-wpijava main LimelightHelpers Reference implementation for LimelightHelpers. Used by the Limelight subsystem above to retrieve pose estimates and raw vision measurements. Limelight.java Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Limelight.java Limelight Code Subsystem that pulls robot pose from LimelightHelpers, validates the estimate, models measurement noise from tag distance/count, and feeds pose+timestamp+std devs to a consumer (e.g., your drivetrain pose estimator). Caches the last valid estimate and exposes getters for logging. RobotContainer.java text-slate-600 dark:text-slate-300 mb-4 src/main/java/frc/robot/RobotContainer.java grid md:grid-cols-2 gap-6 bg-green-50 dark:bg-green-900/20 p-6 rounded-lg border-l-4 border-green-500 text-lg font-semibold text-green-900 dark:text-green-300 mb-4 bg-red-50 dark:bg-red-900/20 p-6 rounded-lg border-l-4 border-red-500 text-lg font-semibold text-red-900 dark:text-red-300 mb-4 grid md:grid-cols-2 gap-4 https://docs.limelightvision.io/docs/docs-limelight/apis/complete-networktables-api Limelight NetworkTables API w-5 h-5 https://docs.wpilib.org/en/stable/docs/software/vision-processing/apriltag/apriltag-intro.html WPILib AprilTag Guide üìù Knowledge Check What is the primary purpose of the LimelightHelpers library? To control motor speeds To provide clean NetworkTables access for vision data without manual subscriptions To generate camera calibration files To replace the gyroscope LimelightHelpers abstracts NetworkTables complexity by providing pre-built wrappers that give clean access to vision data without requiring manual NetworkTables subscriptions. What three values are needed to add vision measurements to the pose estimator? X position, Y position, rotation Pose, timestamp, and standard deviation Distance, angle, and velocity Camera height, tilt angle, and exposure To add vision measurements to the pose estimator, you need: the pose (robot position from vision), the timestamp (when the measurement was taken), and standard deviation (how much to trust the reading). Why is standard deviation important when integrating vision data? It determines camera resolution It controls how much to trust vision measurements, preventing bad data from degrading odometry It sets the camera exposure time It adjusts motor PID gains Standard deviation determines how much the pose estimator should trust a vision measurement. Dynamic standard deviations based on tag count and distance prevent bad measurements from corrupting the robot What does the Limelight subsystem do before passing data to the pose estimator? It increases camera exposure It validates and filters bad measurements It resets the gyroscope It adjusts motor speeds The Limelight subsystem acts as a validation layer that filters bad measurements (poor quality, incorrect data) before they reach the pose estimator, protecting odometry accuracy. How should standard deviation typically change with tag distance and count? Standard deviation stays constant regardless of conditions Standard deviation increases with distance and decreases with more tags visible Standard deviation decreases with distance Standard deviation only depends on camera exposure Standard deviation should increase with distance (farther tags = less accurate) and decrease with more tags visible (more tags = more confident measurement). This models measurement uncertainty appropriately. bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/vision-implementation",
    category: "Workshop 2",
    tags: [
      "vision-implementation",
      "robot",
      "subsystem",
      "ctre",
      "command",
      "workshop",
      "motor",
      "pid",
      "control",
      "java",
      "frc",
    ],
  },
  {
    id: "vision-options",
    title: "Vision Options",
    description:
      "Overview of computer vision options for FRC robots including cameras and vision processing.",
    content:
      "Why Vision Matters in FRC AprilTags provide known field positions, enabling accurate robot localization and drift correction for odometry. Detect and track notes, cones, cubes, or other game pieces for autonomous pickup and scoring. Aim and shoot at targets dynamically, adjusting for robot and target movement in real-time. Modern FRC requires vision for autonomous accuracy and teleop assistance. Top teams use multiple cameras for comprehensive field awareness. FRC Vision System Options Limelight Dedicated vision hardware with integrated processing, LEDs, and NetworkTables interface. Plug-and-play solution optimized for FRC. ‚úÖ Advantages Zero code required for basic detection Built-in LED ring for consistent lighting Hardware-accelerated processing Web interface for tuning pipelines NetworkTables integration out-of-box Proven reliability in competition ‚ö†Ô∏è Limitations Higher cost (~$400-500) Proprietary hardware and software Limited customization vs open source üéØ Best For Teams who want reliable, proven vision hardware with minimal setup. Ideal for teams prioritizing ease-of-use over cost. PhotonVision Open-source vision software that runs on coprocessors (Raspberry Pi, Orange Pi, etc.). Flexible and cost-effective alternative. Free and open source Works with any USB camera Active development and community Advanced AprilTag support Multi-tag pose estimation Lower total cost (~$100-150) Requires coprocessor setup More configuration complexity Camera and lighting selection matters Performance depends on hardware chosen Teams who want cost-effective vision with flexibility and don't mind additional setup complexity. Great for AprilTag localization. Vision System Comparison Feature Cost $400-500 $100-150 Setup Complexity Very Easy Moderate Hardware Integrated unit Coprocessor + Camera AprilTag Support Yes Custom Pipelines Web interface Web interface + Code Community Support Large, established Growing, active Best Use Case Plug-and-play reliability Cost-effective flexibility AprilTag Localization AprilTags are fiducial markers placed at known locations on the FRC field. Cameras can detect these tags and calculate the robot's absolute field position. How AprilTags Work Tags have unique IDs corresponding to field positions Camera detects tag and calculates relative pose Robot position computed from known tag location Multiple tags improve accuracy through fusion Benefits for FRC Corrects odometry drift automatically Enables accurate autonomous navigation Works regardless of starting position Provides absolute field coordinates Many top teams use multiple cameras: one facing forward for game pieces, and others positioned to always see AprilTags for continuous localization. Recommended Approach for This Workshop üì∑ Using Limelight For this workshop, we'll use Limelight for its simplicity and reliability. The focus is on integrating vision data into your robot code, not configuring vision hardware. What You'll Learn Reading vision data from NetworkTables Integrating AprilTag poses into odometry Using vision for target tracking Commanding turrets/shooters based on vision Additional Resources What's Next? Up Next: Implementing Vision You'll integrate Limelight into your swerve drivetrain for AprilTag-based pose estimation and odometry correction. Vision Options /logging-implementation Implementing Logging /vision-implementation Implementing Vision Computer Vision - See the Field Computer vision enables robots to detect game pieces, track targets, and localize position using cameras. AprilTag targets provide absolute field positioning, while object detection helps with game piece manipulation. Vision transforms robots from blind machines into field-aware systems that can adapt to dynamic conditions. flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-3 gap-6 Absolute Positioning Game Piece Detection Target Tracking info üí° Vision is Essential for Competitive Play bg-slate-50 dark:bg-slate-900 rounded-lg p-8 border border-slate-200 dark:border-slate-800 flex items-start gap-4 mb-6 bg-primary-600 text-white rounded-lg px-4 py-2 font-bold text-lg flex-1 text-2xl font-bold text-slate-900 dark:text-slate-100 mb-2 text-slate-600 dark:text-slate-300 grid md:grid-cols-2 gap-6 font-semibold text-slate-900 dark:text-slate-100 mb-3 list-disc list-inside space-y-2 text-sm text-slate-600 dark:text-slate-300 mt-6 text-sm text-slate-600 dark:text-slate-300 https://docs.limelightvision.io/docs/docs-limelight/getting-started/summary Limelight Documentation w-5 h-5 bg-green-600 text-white rounded-lg px-4 py-2 font-bold text-lg https://docs.photonvision.org/ PhotonVision Documentation overflow-x-auto w-full border-collapse border-b-2 border-slate-300 dark:border-slate-700 text-left p-4 font-semibold text-slate-900 dark:text-slate-100 border-b border-slate-200 dark:border-slate-800 p-4 font-medium text-slate-900 dark:text-slate-100 p-4 text-slate-600 dark:text-slate-300 text-xl font-bold text-primary-900 dark:text-primary-300 mb-4 text-xl font-bold text-green-900 dark:text-green-300 mb-4 tip üí° Multi-Camera Setup bg-primary-50 dark:bg-primary-950/30 rounded-lg p-8 border border-slate-200 dark:border-slate-800 text-xl font-semibold text-slate-900 dark:text-slate-100 mb-6 text-slate-600 dark:text-slate-300 mb-6 bg-slate-50 dark:bg-slate-900 p-6 rounded-lg border border-slate-200 dark:border-slate-800 font-bold text-primary-600 dark:text-primary-400 mb-3 grid md:grid-cols-2 gap-4 https://docs.limelightvision.io/ üìù Knowledge Check What is the primary advantage of using Limelight over PhotonVision? Lower cost Open source software Zero code required for basic detection with integrated hardware and LEDs Better AprilTag detection accuracy What do AprilTags provide for FRC robots? Game piece detection Absolute field positioning and odometry drift correction Motor speed control Battery voltage monitoring AprilTags are fiducial markers placed at known locations on the FRC field. When detected by cameras, they provide absolute field positioning by calculating the robot What is a key limitation of PhotonVision compared to Limelight? Cannot detect AprilTags Doesn Requires coprocessor setup and more configuration complexity More expensive PhotonVision requires setting up a coprocessor (like Raspberry Pi), selecting and configuring cameras, and managing lighting, which adds complexity. However, it How do AprilTags calculate robot position? GPS satellites triangulation Camera detects tag, calculates relative pose, then computes robot position from known tag location Ultrasonic distance sensors Wheel encoder integration AprilTags work by having the camera detect the tag and calculate the relative pose (position and angle) between the camera and tag. Since the tag s absolute position can be computed. Multiple tags improve accuracy through fusion. Why do top FRC teams often use multiple cameras? For redundancy in case one fails To see game pieces with one camera while always seeing AprilTags for continuous localization with others To record matches from different angles Because vision processing is faster with multiple cameras Many top teams use a multi-camera setup: one facing forward for game piece detection and manipulation, and others positioned to always see AprilTags for continuous localization. This provides both game-specific vision and reliable position tracking throughout the match. bg-green-50 dark:bg-green-900/20 rounded-lg p-6 border-l-4 border-green-500 text-xl font-semibold text-green-900 dark:text-green-300 mb-4",
    url: "/vision-options",
    category: "Workshop 2",
    tags: [
      "vision-options",
      "frc",
      "robot",
      "hardware",
      "workshop",
      "motor",
      "control",
    ],
  },
  {
    id: "vision-shooting",
    title: "Vision-Based Shooting",
    description:
      "Advanced application combining vision systems with shooting mechanisms for accurate targeting.",
    content:
      "Instead of fixed shooting speeds, dynamic flywheel control adapts in real-time, making your robot more versatile and competitive during matches. Why Dynamic Velocity Control? Fixed Velocity Problems Only accurate from one specific distance Requires driver to position robot precisely Wastes time moving to \"sweet spot\" locations Limited strategic positioning options Multiple preset buttons needed for different zones Dynamic Velocity Benefits Shoot accurately from anywhere on the field Automatic velocity adjustment‚Äîno driver input needed Faster scoring cycles (shoot from current position) More strategic flexibility during matches Single button command handles all distances Understanding Distance-to-Velocity Mapping InterpolatingTreeMap ‚Äîa data structure that stores known distance-velocity pairs and automatically calculates velocities for distances in between. How InterpolatingTreeMap Works You provide key distance-velocity pairs, and the map fills in the gaps automatically using linear interpolation. Example Mapping: Distance: 1.0 m ‚Üí Velocity: 10 RPS Distance: 2.0 m ‚Üí Velocity: 30 RPS Distance: 3.0 m ‚Üí Velocity: 60 RPS üìä Automatic Interpolation: If your robot is at 1.5 meters (between 1.0 and 2.0), the map automatically calculates: 20 RPS Linear interpolation ensures smooth velocity transitions as the robot moves around the field. Implementation Guide Set Up the Lookup Table Create an InterpolatingTreeMap and populate it with distance-velocity pairs based on testing. Start with a few key distance points, then add more data through testing. You don't need every possible distance‚Äîinterpolation handles the values in between! Calculate Distance to Target Use your swerve drivetrain's odometry to get the robot's position, then calculate distance to the target. The target is a fixed field position (e.g., speaker center). In this example, it's at coordinates (3, 5). Update this based on your field layout and game objectives. Create the Distance Shoot Command This command continuously queries the lookup table and adjusts flywheel velocity as the robot moves. ‚ú® Automatic Adjustment As the robot drives around, the periodic() method updates distance , and the command automatically queries the new velocity. No manual intervention required! Workshop Implementation: Dynamic Flywheel 4-DynamicFlywheel branch shows how all the pieces fit together in a real subsystem. Tuning Your Velocity Map Start with closest or farthest distance Put your robot at the closest or farthest distance from the target and manually tune the flywheel velocity until shots are accurate. Test at Key Distances Position your robot at specific distances (1m, 2m, 3m, etc.) and manually tune the flywheel velocity until shots are consistently successful. Test each distance multiple times to account for variability. Record the velocity that gives the best consistency, not just a single lucky shot. Record Successful Velocities Log the distance and corresponding velocity for each successful test. Create a table of proven data points. Distance (m) Velocity (RPS) Success Rate 1.0 10.0 95% 2.0 30.0 90% 3.0 60.0 92% Populate the TreeMap Add your tested distance-velocity pairs to the lookup table in your code. Start with 3-5 key points. Let Interpolation Fill the Gaps Test at intermediate distances (1.5m, 2.5m, etc.) to verify that interpolation is giving good results. Fine-tune by adding more data points if needed. Pro Tip: Try not to add too many points. It is only recommended to add points when you start missing. Dynamic Flywheel Control /swerve-calibration Odom Calibration /state-based State-Based Control Vision-Based Shooting with Dynamic Velocity Using odometry data with an interpolating lookup table, your robot can shoot accurately from anywhere on the field. Use swerve odometry and velocity mapping to achieve consistent shooting from any position without manual adjustment. text-slate-600 dark:text-slate-300 text-center -mt-4 flex flex-col gap-8 text-3xl font-bold text-slate-900 dark:text-slate-100 grid md:grid-cols-2 gap-6 bg-red-50 dark:bg-red-950/30 rounded-lg p-6 border-l-4 border-red-400 dark:border-red-900 text-xl font-bold text-red-800 dark:text-red-300 mb-4 flex items-center gap-2 space-y-2 text-sm text-slate-700 dark:text-slate-300 flex items-start mr-2 bg-green-50 dark:bg-green-950/30 rounded-lg p-6 border-l-4 border-green-400 dark:border-green-900 text-xl font-bold text-green-800 dark:text-green-300 mb-4 flex items-center gap-2 text-slate-600 dark:text-slate-300 flex items-start gap-4 mb-4 bg-blue-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 w-5 h-5 text-xl font-bold text-slate-900 dark:text-slate-100 mb-2 space-y-4 bg-slate-50 dark:bg-slate-900 p-4 rounded-lg border border-slate-200 dark:border-slate-800 font-semibold text-slate-900 dark:text-slate-100 mb-3 space-y-2 text-sm text-slate-600 dark:text-slate-300 flex justify-between p-2 bg-white dark:bg-slate-800 rounded font-mono bg-primary-50 dark:bg-primary-950/30 p-4 rounded-lg border border-primary-200 dark:border-primary-800 font-semibold text-primary-900 dark:text-primary-300 mb-2 text-sm text-slate-700 dark:text-slate-300 mb-2 text-sm font-mono bg-white dark:bg-slate-800 p-2 rounded text-xs text-slate-600 dark:text-slate-400 mt-2 bg-purple-500 text-white rounded-full w-10 h-10 flex items-center justify-center font-bold flex-shrink-0 java Flywheel Subsystem Constructor tip üí° Tuning Tip Periodic Distance Update Distance to Target Target Velocity info üéØ Target Position Dynamic Velocity Command bg-green-50 dark:bg-green-950/30 p-4 rounded-lg border-l-4 border-green-400 dark:border-green-900 mt-4 font-semibold text-green-800 dark:text-green-300 mb-2 text-sm text-slate-700 dark:text-slate-300 Hemlock5712/Workshop-Code src/main/java/frc/robot/subsystems/Flywheel.java Flywheel.java üìã Step-by-Step Tuning Process space-y-6 flex gap-4 bg-primary-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 font-semibold text-slate-900 dark:text-slate-100 text-sm text-slate-600 dark:text-slate-300 mt-1 bg-primary-600 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 warning ‚ö†Ô∏è Test Systematically text-sm bg-primary-700 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-slate-50 dark:bg-slate-900 p-3 rounded mt-2 w-full text-sm border-b border-slate-300 dark:border-slate-700 text-left py-2 bg-primary-800 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 Updated Lookup Table bg-primary-900 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold flex-shrink-0 bg-green-50 dark:bg-green-950/30 p-3 rounded mt-2 border-l-4 border-green-400 dark:border-green-900 text-sm text-green-800 dark:text-green-300 üìù Knowledge Check What is the primary advantage of dynamic flywheel control over fixed velocity shooting? It uses less battery power It automatically adjusts velocity based on distance to target It eliminates the need for PID control It makes the flywheel spin faster Dynamic flywheel control automatically calculates and applies the correct velocity based on the robot What does an InterpolatingTreeMap do? It stores only exact distance-velocity pairs with no calculation It automatically calculates velocities for distances between stored data points It sorts robot positions by distance It replaces the need for odometry An InterpolatingTreeMap stores known distance-velocity pairs and uses linear interpolation to automatically calculate appropriate velocities for distances that fall between your stored data points. How does the flywheel subsystem know the robot The driver manually inputs the distance It uses swerve drivetrain odometry to get robot pose and calculates distance It measures distance with an ultrasonic sensor It estimates based on flywheel motor current The subsystem gets the robot s odometry system, then calculates the Euclidean distance between the robot If your lookup table has entries for 1.0m‚Üí10 RPS and 2.0m‚Üí30 RPS, what velocity will it calculate for 1.5m? 15 RPS 25 RPS 10 RPS The map uses linear interpolation: 10 + (30-10) √ó (1.5-1.0)/(2.0-1.0) = 10 + 20√ó0.5 = 20 RPS. The velocity increases linearly between the two data points. When tuning your velocity map, what is the recommended approach? Test only at the exact distances you Add every possible distance from 0 to maximum range Test at 3-5 key distances and let interpolation fill the gaps Copy values from another team The most efficient approach is to test at 3-5 key distances throughout your shooting range. The InterpolatingTreeMap will automatically calculate appropriate velocities for intermediate distances through linear interpolation. What happens in the distanceShoot() command It sets a fixed velocity and never changes it It continuously queries the lookup table with current distance and updates velocity It only calculates velocity once when the command starts It turns off the flywheel motors The command continuously queries table.get(distance) to get the appropriate velocity for the current distance, then applies it to the flywheel. As the robot moves and distance changes, the velocity automatically adjusts.",
    url: "/vision-shooting",
    category: "Workshop 2",
    tags: [
      "vision-shooting",
      "control",
      "robot",
      "command",
      "workshop",
      "subsystem",
      "java",
      "frc",
      "pid",
      "motor",
    ],
  },
];
